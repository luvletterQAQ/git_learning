>廖雪峰博客：https://www.liaoxuefeng.com/wiki/1252599548343744/1264738568571776
>
>logback：https://www.cnblogs.com/warking/p/5710303.html

# 一、JDK Logging

>```java
>public class Hello {
>    public static void main(String[] args) {
>        //Logger logger = Logger.getLogger("com.hfut.test.xxx");
>        Logger logger = Logger.getGlobal();
>        logger.info("info...");
>        logger.warning("warning...");
>        logger.fine("fine...");
>        logger.severe("severe...");
>    }
>}
>/*	输出信息：
>    四月 11, 2023 4:16:32 下午 com.hfut.test.CGlibTest main
>    信息: info...
>    四月 11, 2023 4:16:32 下午 com.hfut.test.CGlibTest main
>    警告: warning...
>    四月 11, 2023 4:16:32 下午 com.hfut.test.CGlibTest main
>    严重: severe...
>*/
>```
>
>```java
>//getLogger()是使用LogManager.java通过参数获取一个Logger.java实例，相同name会取得统一对象
>public static void main(String[] args) throws Exception{	
>	Logger log = Logger.getLogger(Test.class.getName());
>    Logger log2 = Logger.getLogger("Test");
>    Logger log3 = Logger.getLogger("Test2");
>
>    System.out.println("同  名logger：" + (log == log2) );
>    System.out.println("不同名logger:"+ (log2 == log3) );
>}
>/*	
>	版权声明：本文为CSDN博主「qianggetaba」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
>	原文链接：https://blog.csdn.net/c5113620/article/details/79075729
>*/
>```
>
>
>
>使用日志最大的好处是，它自动打印了时间、调用类、调用方法等很多有用的信息。
>
>`logger.fine()`没有打印。这是因为，日志的输出可以设定级别。JDK的Logging定义了7个日志级别，从严重到普通：
>
>- SEVERE
>- WARNING
>- INFO
>- CONFIG
>- FINE
>- FINER
>- FINEST
>
>因为默认级别是INFO，因此，INFO级别以下的日志，不会被打印出来。使用日志级别的好处在于，调整级别，就可以屏蔽掉很多调试相关的日志输出。
>
>使用Java标准库内置的Logging有以下局限：
>	Logging系统在JVM启动时读取配置文件并完成初始化，一旦开始运行`main()`方法，就无法修改配置；
>	配置不太方便，需要在JVM启动时传递参数```-Djava.util.logging.config.file=<config-file-name>```。
>	因此，Java标准库内置的Logging使用并不是非常广泛。

# 二、Commons Logging

>和Java标准库提供的日志不同，Commons Logging是一个第三方日志库，它是由Apache创建的日志模块。
>
>Commons Logging的特色是，它可以挂接不同的日志系统，并通过配置文件指定挂接的日志系统。默认情况下，Commons Loggin自动搜索并使用Log4j（Log4j是另一个流行的日志系统），如果没有找到Log4j，再使用JDK Logging。
>
>使用Commons Logging只需要和两个类打交道，并且只有两步：
>	第一步，通过`LogFactory`获取`Log`类的实例； 第二步，使用`Log`实例的方法打日志。
>
>```java
>public class Main {
>    public static void main(String[] args) {
>        Log log = LogFactory.getLog(Main.class);
>        log.info("start...");
>        log.warn("end.");
>    }
>}
>```
>
>Commons Logging定义了6个日志级别：默认级别是`INFO`
>
>- FATAL
>- ERROR
>- WARNING
>- INFO
>- DEBUG
>- TRACE

# 三、Log4j

>https://www.cnblogs.com/wangzhuxing/p/7753420.html
>

>前面介绍了Commons Logging，可以作为“日志接口”来使用。而真正的“日志实现”可以使用Log4j。
>
>Log4j是一个组件化设计的日志系统，它的架构大致如下：
>
>```java
>log.info("User signed in.");
> │
> │   ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐
> ├──>│ Appender │───>│  Filter  │───>│  Layout  │───>│ Console  │
> │   └──────────┘    └──────────┘    └──────────┘    └──────────┘
> │
> │   ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐
> ├──>│ Appender │───>│  Filter  │───>│  Layout  │───>│   File   │
> │   └──────────┘    └──────────┘    └──────────┘    └──────────┘
> │
> │   ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐
> └──>│ Appender │───>│  Filter  │───>│  Layout  │───>│  Socket  │
>         └──────────┘    └──────────┘    └──────────┘    └──────────┘
>```
>
>当我们使用Log4j输出一条日志时，Log4j自动通过不同的Appender把同一条日志输出到不同的目的地。例如：
>
>- console：输出到屏幕；
>- file：输出到文件；
>- socket：通过网络输出到远程计算机；
>- jdbc：输出到数据库
>
>在输出日志的过程中，通过Filter来过滤哪些log需要被输出，哪些log不需要被输出。例如，仅输出`ERROR`级别的日志。
>
>最后，通过Layout来格式化日志信息，例如，自动添加日期、时间、方法名称等信息。
>
>上述结构虽然复杂，但我们在实际使用的时候，并不需要关心Log4j的API，而是通过配置文件来配置它。两种配置方式，xml和properties。==没有配置文件log4j不生效==。
>
>以XML配置为例，使用Log4j的时候，我们把一个`log4j2.xml`的文件放到`classpath`下就可以让Log4j读取配置文件并按照我们的配置来输出日志。
>
>虽然配置Log4j比较繁琐，但一旦配置完成，使用起来就非常方便。对上面的配置文件，凡是`INFO`级别的日志，会自动输出到屏幕，而`ERROR`级别的日志，不但会输出到屏幕，还会同时输出到文件。并且，一旦日志文件达到指定大小（1MB），Log4j就会自动切割新的日志文件，并最多保留10份。
>
>要打印日志，只需要按Commons Logging的写法写，不需要改动任何代码，就可以得到Log4j的日志输出。因为Commons Logging会自动发现并使用Log4j。

>Log4j1与Log4j2的区别
>设计理念的区别、配置文件的区别、配置文件名的区别。
>
>slf4j的成功在于他的高屋建瓴，俯视一切。
>slf4j是日志门面（像：java的接口，没有提供任何实现），通过提供各种桥接器，适配各种日志框架（Log4j1，logback等）。
>
>Log4j1并没有这样的高度，于是Log4j2就借鉴了slf4j的设计。
>Log4f2有两部分组成：log4j-api、log4j-core。
>其中log4j-api和slf4j是相同的，都是日志门面，log4j-core则是对log4j-api的实现，和log4j1、logback是相同的， 并且通过桥接器log4j-api还可以适配其他的日志系统（logback等）。
>就这样，Log4j2集成了slf4j与logback的优点，成为了Log4j的一次重生。
>
>核心Jar包的区别
>
>上面我们就说了，Log4j有两部分组成，分别是log4j-api、log4j-core
>
>而在Log4j1中，Log4j的核心包只有log4j:log4j:[version]
>
>```xml
>//log4j1:
><dependency>
>    <groupId>log4j</groupId>
>    <artifactId>log4j</artifactId>
>    <version>1.2.17</version>
></dependency>
>```
>
>而log4j2的核心包有2个：
>
>org.apache.logging.log4j:log4j-core:[version]
>org.apache.logging.log4j:log4j-api:[version]
>
>```xml
>//log4j2：
><dependency>
>  <groupId>org.apache.logging.log4j</groupId>
>  <artifactId>log4j-api</artifactId>
>  <version>2.14.1</version>
></dependency>
>//log4j-core包中已经引入了log4j-api
><dependency>
>  <groupId>org.apache.logging.log4j</groupId>
>  <artifactId>log4j-core</artifactId>
>  <version>2.14.1</version>
></dependency>
>```
>
>————————————————
>版权声明：本文为CSDN博主「野犬17」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
>原文链接：https://blog.csdn.net/idler123/article/details/121962109

## 如何配置log4j.xml

>配置文件名必须为 log4j.xml，这是log4j第一版本的配置文件。

### 1 日志等级

[log4j](https://so.csdn.net/so/search?q=log4j&spm=1001.2101.3001.7020) 日志等级分为五级：

| 等级  | 说明                             |
| :---: | -------------------------------- |
| DEBUG | 调试（细粒度）。                 |
| INFO  | 应用程序的运行过程（粗粒度）。   |
| WARN  | 可能存在潜在错误。               |
| ERROR | 发生错误事件，但不影响系统运行。 |
| FATAL | 发生严重错误事件，导致系统退出。 |

一般只使用到前四种。

### 2 目标

我们希望这样管理日志： 1、日志放在 logs/web/ 下。 2、日志文件分为 debug.log、info.log 以及  error.log。 3、每小时生成一份日志文件。 4、debug.log 包含所有级别日志。 5、info.log 包含除 debug  之外的所有级别日志。 6、error.log 包含 ERROR、FATAL 日志。

### 3 配置

配置文件 xxx.xml，放置在 `classes/`：

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE log4j:configuration SYSTEM "log4j.dtd">
 
<log4j:configuration>
 
    <!-- 控制台日志-->
    <appender name="ConsoleAppender" class="org.apache.log4j.ConsoleAppender">
        <layout class="org.apache.log4j.PatternLayout">
            <param name="ConversionPattern" value="[%d{yyyy-MM-dd HH:mm:ss.SSS}] [%p]:[%c][%M] \
  [%l] [%m] %n"/>
        </layout>
    </appender>
 
    <!-- DEBUG 级别日志-->
    <appender name="debugAppender" class="org.apache.log4j.DailyRollingFileAppender">
        <!-- 日志输出路径-->
        <param name="File" value="${catalina.base}/logs/web/debug.log"/>
 
        <!-- 每小时生成一个新日志-->
        <param name="DatePattern" value="'.'yyyy-MM-dd-HH'.log'"/>
 
        <filter class="org.apache.log4j.varia.LevelRangeFilter">
            <!-- 最低级别-->
            <param name="levelMin" value="DEBUG"/>
        </filter>
 
        <!-- 日志输出格式-->
        <layout class="org.apache.log4j.PatternLayout">
            <param name="ConversionPattern"
                   value="[%d{yyyy-MM-dd HH:mm:ss.SSS}] [%p]: [%c][%M][%l] [%m] %n"/>
        </layout>
    </appender>
 
    <!-- INFO 级别日志-->
    <appender name="infoAppender" class="org.apache.log4j.DailyRollingFileAppender">
        <!-- 日志输出路径-->
        <param name="File" value="${catalina.base}/logs/web/info.log"/>
 
        <!-- 每小时生成一个新日志-->
        <param name="DatePattern" value="'.'yyyy-MM-dd-HH'.log'"/>
 
        <filter class="org.apache.log4j.varia.LevelRangeFilter">
            <!-- 最低级别-->
            <param name="levelMin" value="INFO"/>
        </filter>
 
        <!-- 日志输出格式-->
        <layout class="org.apache.log4j.PatternLayout">
            <param name="ConversionPattern"
                   value="[%d{yyyy-MM-dd HH:mm:ss.SSS}] [%p]: [%c][%M][%l] [%m] %n"/>
        </layout>
    </appender>
 
    <!-- Error 级别日志-->
    <appender name="errorAppender" class="org.apache.log4j.DailyRollingFileAppender">
        <!-- 日志输出路径-->
        <param name="File" value="${catalina.base}/logs/web/error.log"/>
 
        <!-- 每小时生成一个新日志-->
        <param name="DatePattern" value="'.'yyyy-MM-dd-HH'.log'"/>
 
        <filter class="org.apache.log4j.varia.LevelRangeFilter">
            <!-- 最低级别-->
            <param name="levelMin" value="ERROR"/>
        </filter>
 
        <!-- 日志输出格式-->
        <layout class="org.apache.log4j.PatternLayout">
            <param name="ConversionPattern"
                   value="[%d{yyyy-MM-dd HH:mm:ss.SSS}] [%p]: [%c][%M][%l] [%m] %n"/>
        </layout>
    </appender>
 
 
    <root>
        <priority value="debug"/>
        <appender-ref ref="ConsoleAppender"/>
        <appender-ref ref="debugAppender"/>
        <appender-ref ref="infoAppender"/>
        <appender-ref ref="errorAppender"/>
    </root>
 
</log4j:configuration>
```

### 4 输出器

|          输出器          | 说明                                       |
| :----------------------: | ------------------------------------------ |
|     ConsoleAppender      | 控制台。                                   |
|       FileAppender       | 文件。                                     |
|   RollingFileAppender    | 文件，当文件大小达到一定阈值时，自动备份。 |
| DailyRollingFileAppender | 文件，可设置定期备份策略。                 |
|      WriterAppender      | 将日志信息以流格式发送到指定位置。         |

### 5 输出格式

| 格式 | 说明                                                         |
| :--: | ------------------------------------------------------------ |
|  %c  | 输出日志信息所属的类的全名                                   |
|  %d  | 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d{yyy-MM-dd HH:mm:ss }，输出类似：2002-10-18- 22：10：28 |
|  %f  | 输出日志信息所属的类的类名                                   |
|  %l  | 输出日志事件的发生位置，即输出日志信息的语句处于它所在的类的第几行 |
|  %m  | 输出代码中指定的信息，如log(message)中的message              |
|  %n  | 输出一个回车换行符，Windows平台为“/r/n”，Unix平台为“/n”      |
|  %p  | 输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL。如果是调用debug()输出的，则为DEBUG，依此类推 |
|  %r  | 输出自应用启动到输出该日志信息所耗费的毫秒数                 |
|  %t  | 输出产生该日志事件的线程名                                   |

### 6 DatePattern

DailyRollingFileAppender 中可以设置日志生成的时间频度（DatePattern），格式如下：

| 时间频度 | 格式             |
| :------: | ---------------- |
|   每月   | yyyy-MM          |
|   每周   | yyyy-ww          |
|   每天   | yyyy-MM-dd       |
|  每半天  | yyyy-MM-dd-a     |
|  每小时  | yyyy-MM-dd-HH    |
|  每分钟  | yyyy-MM-dd-HH-mm |

形如：

```bash
 <param name="DatePattern" value="'.'yyyy-MM-dd-HH'.log'"/>
```

> **注意：** 1、不在表中的字符，必须写在 `''` 之间。 2、必须遵循操作系统文件夹的命名规范。

如果不遵守这些规则，可是会静默失败的哦O(∩_∩)O~

### 7 LevelRangeFilter

每一个 appender，都可以配置一个 LevelRangeFilter（日志等级过滤器），来指定需要输出的日志范围。

|   参数   | 说明     |
| :------: | -------- |
| levelMin | 最低等级 |
| levelMax | 最高等级 |

等级可选值为：OFF、FATAL、ERROR、WARN、、INFO、DEBUG、TRACE、ALL。

### 8 日志输出路径

可以使用 `${catalina.base}` 来指定 Tomcat 的根目录。

转载于:https://juejin.im/post/5c879c9a6fb9a049e82c5e55

## 如何配置log4j2.xml

>配置文件名必须为 log4j2.xml，这是log4j第二版本的配置文件。

>```xml
><?xml version="1.0" encoding="UTF-8"?>
><Configuration>
>   <!--这里定义的属性是方便下面的标签使用的  是自定义的-->
>	<Properties>
>       <!-- 自定义日志格式 -->
>		<Property name="log.pattern">%d{MM-dd HH:mm:ss.SSS} [%t] %-5level %logger{36}%n%msg%n%n</Property>
>       <!-- 自定义文件名变量 -->
>		<Property name="file.err.filename">log/err.log</Property>
>		<Property name="file.err.pattern">log/err.%i.log.gz</Property>
>	</Properties>
>
>   <!-- 定义Appender，即目的地 -->
>	<Appenders>
>       <!-- 定义输出到屏幕 -->
>		<Console name="console" target="SYSTEM_OUT">
>           <!-- 日志格式引用上面定义的log.pattern -->
>			<PatternLayout pattern="${log.pattern}" />
>		</Console>
>       <!-- 定义输出到文件,文件名引用上面定义的file.err.filename -->
>		<RollingFile name="err" bufferedIO="true" fileName="${file.err.filename}" filePattern="${file.err.pattern}">
>			<PatternLayout pattern="${log.pattern}" />
>			<Policies>
>               <!-- 根据文件大小自动切割日志 -->
>				<SizeBasedTriggeringPolicy size="1 MB" />
>			</Policies>
>           <!-- 保留最近10份 -->
>			<DefaultRolloverStrategy max="10" />
>		</RollingFile>
>	</Appenders>
>
>	<Loggers>
>		<Root level="info">
>           <!-- 对info级别的日志，输出到console -->
>			<AppenderRef ref="console" level="info" />
>           <!-- 对error级别的日志，输出到err，即上面定义的RollingFile -->
>			<AppenderRef ref="err" level="error" />
>		</Root>
>	</Loggers>
></Configuration>
>```

# 四、SLF4J和Logback

>https://www.cnblogs.com/warking/p/5710303.html
>
>配置文件名为logback.xml

>SLF4J类似于Commons Logging，也是一个日志接口，而Logback类似于Log4j，是一个日志的实现。因为对Commons Logging的接口不满意，有人就搞了SLF4J。因为对Log4j的性能不满意，有人就搞了Logback。
>
>我们先来看看SLF4J对Commons Logging的接口有何改进。在Commons Logging中，我们要打印日志，有时候得这么写：
>
>```java
>int score = 99;
>p.setScore(score);
>log.info("Set score " + score + " for Person " + p.getName() + " ok.");
>```
>
>拼字符串是一个非常麻烦的事情，所以SLF4J的日志接口改进成这样了：
>
>```java
>int score = 99;
>p.setScore(score);
>logger.info("Set score {} for Person {} ok.", score, p.getName());
>```
>
>我们靠猜也能猜出来，SLF4J的日志接口传入的是一个带占位符的字符串，用后面的变量自动替换占位符，所以看起来更加自然。
>
>如何使用SLF4J？它的接口实际上和Commons Logging几乎一模一样：
>
>```java
>import org.slf4j.Logger;
>import org.slf4j.LoggerFactory;
>
>class Main {
>    final Logger logger = LoggerFactory.getLogger(getClass());
>}
>```
>
>对比一下Commons Logging和SLF4J的接口：
>
>| Commons Logging                       | SLF4J                   |
>| ------------------------------------- | ----------------------- |
>| org.apache.commons.logging.Log        | org.slf4j.Logger        |
>| org.apache.commons.logging.LogFactory | org.slf4j.LoggerFactory |
>
>不同之处就是Log变成了Logger，LogFactory变成了LoggerFactory。
>
>然后使用SLF4J的Logger和LoggerFactory即可。和Log4j类似，我们仍然需要一个Logback的配置文件，把`logback.xml`放到classpath下，配置如下：
>
>```xml
><?xml version="1.0" encoding="UTF-8"?>
><configuration>
>
>	<appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
>		<encoder>
>			<pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
>		</encoder>
>	</appender>
>
>	<appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
>		<encoder>
>			<pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
>			<charset>utf-8</charset>
>		</encoder>
>		<file>log/output.log</file>
>		<rollingPolicy class="ch.qos.logback.core.rolling.FixedWindowRollingPolicy">
>			<fileNamePattern>log/output.log.%i</fileNamePattern>
>		</rollingPolicy>
>		<triggeringPolicy class="ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy">
>			<MaxFileSize>1MB</MaxFileSize>
>		</triggeringPolicy>
>	</appender>
>
>	<root level="INFO">
>		<appender-ref ref="CONSOLE" />
>		<appender-ref ref="FILE" />
>	</root>
></configuration>
>```
>
>```xml
><?xml version="1.0" encoding="UTF-8"?>
>
><configuration debug="false">
>	<!--定义日志文件的存储地址 勿在 LogBack 的配置中使用相对路径-->
>	<property name="LOG_HOME" value="/home" />
>	
>	<!-- 控制台输出 -->
>	<appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
>		<encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">
>			<!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符-->
>			<pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n</pattern>
>		</encoder>
>	</appender>
>	
>	<!-- 按照每天生成日志文件 -->
>	<appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
>		<rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
>			<!--日志文件输出的文件名-->
>			<FileNamePattern>${LOG_HOME}/TestWeb.log.%d{yyyy-MM-dd}.log</FileNamePattern>
>			
>			<!--日志文件保留天数-->
>			<MaxHistory>30</MaxHistory>
>		</rollingPolicy>
>		
>		<encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">
>			<!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符-->
>			<pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n</pattern>
>		</encoder>
>		
>		<!--日志文件最大的大小-->
>		<triggeringPolicy class="ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy">
>			<MaxFileSize>10MB</MaxFileSize>
>		</triggeringPolicy>
>	</appender>
>
>	<!-- 日志输出级别 -->
>	<root level="INFO">
>		<appender-ref ref="STDOUT" />
>	</root>
></configuration>
>
>```
>

