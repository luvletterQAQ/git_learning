
<dependencies>
        <!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api -->
        <dependency>
            <groupId>javax.servlet</groupId>
            <artifactId>javax.servlet-api</artifactId>
            <version>4.0.1</version>
        </dependency>

        <!-- https://mvnrepository.com/artifact/javax.servlet.jsp/javax.servlet.jsp-api -->
        <dependency>
            <groupId>javax.servlet.jsp</groupId>
            <artifactId>javax.servlet.jsp-api</artifactId>
            <version>2.3.1</version>
        </dependency>

    </dependencies>
	
//编码问题P624 Global对象
https://www.cnblogs.com/wxh0929/p/11130464.html   //编码

get方式请求：
	浏览器默认是UTF-8编码，将提交内容合并到url之后再经过url编码，传输到服务器后，
	request.getParameter("name") 内部通过UTF-8的URL解码转换为正常结果
post方式请求：
	浏览器默认UTF-8编码，通过请求体传输到服务器后，服务器需要解码，但是System.out.println(req.getCharacterEncoding());
	的结果是null，需要将解码方式设定为和浏览器编码方式一样，设置为UTF-8，req.setCharacterEncoding("UTF-8");才能在服务端
	得到中文正确结果
响应：
	需要将服务端编码方式和浏览器解码方式设置为一致，浏览器默认解码方式为UTF-8，通过System.out.println(resp.getCharacterEncoding());
	得知，Tomcat服务器默认编码方式为iso-8859-1，需要修改为UTF-8，response.setCharacterEncoding("UTF-8");
	如果不知道浏览器解码方式，可以通过response.setHeader("content-type", "text/html; charset=utf-8");来告诉浏览器通过utf-8来解码
	或者更简单的方式：response.setcontentType( "text/html;charset=utf-8");  //设置服务器编码格式为utf-8 并且告诉浏览器用utf-8解码
	
System.out.println(req.getCharacterEncoding());    //null  		默认是null
System.out.println(resp.getCharacterEncoding());   //iso-8859-1   默认是iso-8859-1 


https://javaee.github.io/javaee-spec/javadocs/   //api
##web相关概念回顾
	1．软件架构
		1.C/S:客户端/服务器端
		2.B/S:浏览器/服务器端
	2．资源分类
		1．静态资源∶所有用户访问后，得到的结果都是一样的，称为静态资源.静态资源可以直接被浏览器解析*如: html,css,Javascript
		2，动态资源:每个用户访问相同资源后，得到的结果可能不一样。称为动态资源。动态资源被访问后，需要先转换为静态资源，在返回给浏览器*如: servlet/jsp,php,asp.. ..
	3。网络通信三要秦
		1.IP∶电子设备(计算机)在网络中的唯一标识。
		2．端口∶应用程序在计算机中的唯一标识。O~655363.
		传输协议︰规定了数据传输的规则
			1．基础协议︰
				1. tcp:安全协议，三次握手。速度稍慢
				2. udp :不安全协议。速度快

##web服务器软件:
	*服务器:安装了服务器软件的计算机
	*服务器软件:接收用户的请求，处理请求，做出响应
	*web服务器软件:接收用户的请求，处理请求，做出响应。
		*在web服务器软件中，可以部署web项目，让用户通过浏览器来访问这些项目
		*web容器
*常见的java相关的web服务器软件∶
	*webLogic : oracle公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。
	*websphere : IBM公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。
	*JBOSS :JBOSs公司的，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。
	*Tomcat : Apache基金组织，中小型的JavaEE服务器，仅仅支持少量的javaEE规范servlet/jsp。开源的，免费的。
*JavaEE : Java语言在企业级开发中使用的技术规范的总和，一共规定了13项大的规范

tomcat：
	目录结构：
		bin：可执行文件
		conf：配置文件
		lib：依赖jar包 tomcat启动需要依赖这些jar包
		logs：日志文件
		temp：临时文件
		webapps：存放web项目
		work：存放运行时的数据
	conf/server.xml配置文件可以修改默认端口号
部署项目的方式：
	1.直接将项目放到webapp目录下
		/hello :项目的访问路径-->虚拟目录
		*简化部署:将项目打成一个war包，再将war包放置到webapps目录下。
		*war包会自动解压缩	
	2。配置conf/server.xml文件
		在<Host>标签体中配置
		<context docBase="D:\hello" path="/hehe" />
			*docBase:项目存放的路径
			*path:虚拟目录

	3.在conf\catalina\localhost创建任意名称的xml文件。在文件中编写
		<context docBase="D: \hello”/>
		*虚拟目录:xml文件的名称

静态项目和动态项目：
	目录结构：
		java动态项目的目录结构：
			项目的根目录：
				WEB-INF目录：
					web.xml:web项目的核心配置文件
					classes：放置字节码文件的目录
					lib目录：放置依赖的jar包
				静态资源

##Servlet : server applet
*概念:运行在服务器端的小程序
	*Servlet就是一个接口，定义了Java类被浏览器访问到(tomcat识别)的规则。 (用户访问到的服务端的动态资源不一样 有一定的逻辑性来控制 就由Java代码来控制)
	*将来我们自定义一个类，实现servlet接口，复写方法。

*快速入门:
1．创建JavaEE项目
2．定义一个类，实现servlet接口
3．实现接口中的抽象方法
4．配置Servlet

在web.xml中配置:
<!--配置servlet -->
<servlet>
	<servlet-name>demo1</servlet-name>
	<servlet-class>com.hfut.web.servlet.servletDemo1</servlet-class>
</servlet>

<servlet-mapping>
	<servlet-name>demo1</servlet-name>
	<url-pattern>/demo1</url-pattern>
</servlet-mapping>


执行原理：
	1.当服务器接受到客户端浏览器的请求后，会解析请求URL路径，获取访问的servlet的资源路径
	2.查找web.xml文件，足否有对应的<url-pattern>标签体内容。
	3.如果有，则在找到对应的<servlet-class>全类名
	4.tomcat会将字节码文件加载进内存，并且创建其对象
	5.调用其方法
servlet中的生命周期︰
	1．被创建:执行init方法，只执行一次
	2．提供服务∶执行service方法，执行多次
	3．被销毁:执行destroy方法，只执行一次
	getServletConfig方法：获取ServletConfig对象(Servlet的配置对象)
	getServletInfo方法：获取Servlet的一些信息、版本、作者等...


servlet中的生命周期方法∶
	1．被创建:执行init方法，只执行一次
		*servlet什么时候被创建?
			*默认情况下，第一次被访问时，servlet被创建
			*可以配置执行servlet的创建时机。
				*在<servlet>标签下配置
					1．页面第一次被访问时，创建
						*<load-on-startup>的值为负数
					2．在服务器启动时，创建
						*<load-on-startup>的值为0或正整数  如果是正数  数值小的先创建
		* servlet的init方法，只执行一次，说明一个servlet在内存中只存在一个对象，servlet是单例的
			*多个用户同时访问时，可能存在线程安全问题。
			*解决:尽不要在servlet中定义成员变·。即使定义了成员变，也不要对其修改值
	2．提供服务∶执行service方法，执行多次
		每次访问servlet时，Service方法都会被调用一次。
	3．被销毁:执行destroy方法，只执行一次
		Servlet被销毁时执行。服务器关闭时，Servlet被销毁
		只有服务器正常关闭时，才会执行destroy方法。
		destroy方法在servlet被销毁之前执行，一般用于释放资源

* servlet3.0 :
	*好处∶	
		支持注解配置。可以不要web.xml 了。
	*步骤∶
		1．创建JavaEE项目，选择servlet的版本3.0以上，可以不创建web.xml
		2．定义一个类，实现servlet接口
		3．写方法
		4．在类上使用@webServlet注解，进行配置
			@webservlet("资源路径")

Using CATALINA_BASE:   "C:\Users\wangyan\AppData\Local\JetBrains\IntelliJIdea2021.2\tomcat\2f344bd5-348a-4567-b0cd-e28d22df7a67"

##IDEA与tomcat的相关配置
	1.IDEA会为每一个tomcat部署的项目单独建立一份配置文件  这是IDEA自带的tomcat  其中采用了上述第三种项目部署的方式
		*查看控制台的log : using CATALINA BASE:"C:\Users\wangyan\AppData\Local\JetBrains\IntelliJIdea2021.2\tomcat\2f344bd5-348a-4567-b0cd-e28d22df7a67"
	2．工作空间项目   和 	tomcat部署的web项目
		tomcat部署的web项目就在CATALINA BASE:"C:\Users\wangyan\AppData\Local\JetBrains\IntelliJIdea2021.2\tomcat\
			2f344bd5-348a-4567-b0cd-e28d22df7a67\conf\Catalina\localhost\*.xml"文件中的docBase属性对应的目录下，这也就是第三
			种项目部署方式  docBase属性的值一般都是项目下的out文件中  out文件存放部署的项目  target存放编译后的文件
		*tomcat真正访问的是"tomcat部署的web项目”，"tomcat部署的web项目"对应着"工作空间项目"的web目录下的所有资源
	3．断点调试∶使用"小虫子"启动dubug启动
servlet的体系结构
	Servlet --接口
		 ⬇
	Genericservlet --抽象类
		 ⬇
	Httpservlet --抽象类
	* GenericServlet :将servlet接口中其他的方法做了默认空实现，只将service()方法作为抽象
		*将来定义servlet类时，可以继承Genericservlet，实现service()方法即可
	*Httpservlet : 对http协议的一种封装，简化揉作
		1．定义类继承Httpservlet
		2．复写doGet/ doPbst方法

Servlet相关配置
	1. urlpartten: servlet访问路径
		1.一个servlet可以定义多个访问路径︰ @webservlet({"/d4" , "/dd4" , "/ddd4"})
		2．路径定义规则∶
			1./xxx
			2./xxx/xxx:多层路径，目录结构
			3.*.do


## HTTP :
	*概念:Hyper Text Transfer Protocol超文本传输协议
	*传输协议:定义了，客户端和服务器端通信时，发送数据的格式
	*特点:
		1．基于TCP/IP的高级协议
		2．默认端口号:80
		3．基于请求/响应模型的:一次请求对应一次响应
		4．无状态的:每次请求之间相互独立，不能交互数据
	*历史版本∶
		*1.0：每一次请求响应都会建立新的连接
		*1.1：复用连接

*请求消息数据格式
	1.请求行
		请求方式 请求url 请求协议/版本     //格式
		GET /login.html HTTP/1.1
		*请求方式:
			HTTP协议有7中请求方式，常用的有2种
				GET:
					1．请求参数在请求行中，在url后。
					2．请求的url长度有限制的
					3．不太安全
				POST :
					1．请求参数在请求体中
					2．请求的url长度没有限制的
					3．相对安全
	2．请求头:客户端浏览器告诉服务器一些信息
		请求头名称:请求头值 			//格式  键值对
		*常见的请求头∶:
			1. User-Agent :浏览器告诉服务器，我访问你使用的浏览器版本信息
				*可以在服务器端获取该头的信息，解决浏览器的兼容性问题
			2. Referer：http://localhost/login.html
				*告诉服务器，我(当前请求)从哪里来?
				*作用∶
					1．防盗链    其他人网页的超链接链接到优酷视频播放界面，要防止这种现象  
					2．统计工作  给自己某个页面打广告时，统计页面的来源
			其他：
				Accept：告诉服务器我可以接受什么格式的响应  例如 text/html xml等等
				Accept-language：我可以接受的语言
				Accept-Encoding：我可以接受的压缩格式
				Connection：keep-alive   表示连接可以复用


	3．请求空行
		空行  分割POST请求头和请求体的
	4．请求体(正文)
		封装POST请求消息的请求参数的

##Request :
	1. request对象和response对象的原理
		1. request和response对象是由服务器创建的。我们来使用它们
		2. request对象是来获取请求消息，response对象是来设置响应消息

	2. request对象继承体系结构︰
		servletRequest --接口
		        ⬇
		HttpservletRequest --接口
		 		⬇
		org.apache.catalina.connector.RequestFacade 类(tomcat)

	3. request功能:获取请求消息
		1．获取请求行数据
			*GET /day14/demo1?name=zhangsan HTTP/1.1
			*方法:
				1．获取请求方式:GET
					String getMethod()
				2.(*)获取虚拟目录:/day14
					String getcontextPath()
				3．获取servlet路径:/demo1
					String getservletPath()
				4．获取get方式请求参数:name=zhangsan
					String getQuerystring()
				5．(*)获取请求URI : /day14/demo1
					String getRequestURI(): 	/day14/demo1
					StringBuffer getRequestURL()：http://localhost/day14/demo1
					URL:统一资源定位符: http://localhost/day14/demo1 	
					URI:统一资源标识符: /day14/demo1 					

				6．获取协议及版本:HTTP/1.1
					String getProtocol()
				7．获取客户机的IP地址:
				 	String getRemoteAddr()
		2．获取请求头数据
			方法∶
				*(*)String getHeader(string name):通过请求头的名称获取请求头的值
				*Enumeration<String> getHeaderNames():获取所有的请求头名称
		3．获取请求体数据:
			*请求体:只有POST请求方式，才有请求体，在请求体中封装了POST请求的请求参数术
			步骤∶
				1.获取流对象
					BufferedReader getReader():获取字符输入流，只能操作字符数据
					ServletInputStream getInputStream():获取字节输入流，可以操作所有类型数据 		在文件上传知识点后讲解
				2．再从流对象中拿数据
		2．其他功能︰
			1．获取请求参数通用方式∶不论get还是post请求方式都可以使用下列方法来获取请求参数
				1. String getParameter(string name):根据参数名称获取参数值username=zs&password=123
				2. String[] getParameterValues(String name):根据参数名称获取参数值的数组hobby=xx&hobby=game
				3. Enumeration<string> getParameterNames():获取所有请求的参数名称
				4. Map<string,string[]>getParameterMap():获取所有参数的map集合
				*中文乱码问题:（获得浏览器表单的参数和值为中文时 显示在服务器上是乱码 要解码）
					get方式: tomcat 8 已经将get方式乱码问题解决了
					post方式:会乱码
						*解决∶在获取参数前，设置request的编码request.setCharacterEncoding("utf-8");
			2.请求转发∶—种在服务器内部的资源跳转方式
				1．步骤︰
					1，通过request对象获取请求转发器对象∶RequestDispatcher getRequestDispatcher(String path)
					2．使用RequestDispatcher对象来进行转发:forward(ServletRequest request，ServletResponse response)
				2．特点:
					1．浏览器地址栏路径不发生变化
					2．只能转发到当前服务器内部资源中。
					3.转发是一次请求
			3．共享数据︰
				*域对象:一个有作用范围的对象，可以在范围内共享数据
				*request域:代表一次请求的范围，一般用于请求转发的多个资源中共享数据
					*方法:
						1. void setAttribute(String name,object obj):存储数据
						2. object getAttitude(string name):通过键获取值
						3. void removeAttribute(string name):通过键移除键值对
			4．获取servletcontext :
				*Servletcontext getServletContext()

响应消息数据格式：
	响应消息:服务器端发送给客户端的数据
		数据格式:
			1．响应行
				1．组成:协议/版本 响应状态码 状态码描述	
						HTTP/1.1     200        OK
				2．响应状态码∶服务器告诉客户端浏览器本次请求和响应的一个状态。
					1．状态码都是3位数字
					2．分类︰
						1xx：服务器就收客户端消息，但没有接受完成，等待一段时间后，发送1xx多状态码
						2xx：成功。代表:200
						3xx：重定向。代表:302(重定向)，304(访问缓存)
						4xx：客户端错误。
							*代表:
								*404(请求路径没有对应的资源)
								*405 :请求方式没有对应的doxxx方法
						5xx：服务器端错误。代表:500(服务器内部出现异常)
			2．响应头
				1.格式： 头名称：值(键值对)
				2．常见的响应头∶
					1. Content-Type∶服务器告诉客户端本次响应体数据格式以及编码格式
					2. content-disposition:服务器告诉客户端以什么格式打开响应体数据
						*值:
							* in-line:默认值,在当前页面内打开
							* attachment;filename=xxx:以附件形式打开响应体。文件下载
			3．响应空行
			4. 响应体：传输的数据

##Response对象
	*功能∶设置响应消息
	1.设置响应行
		1．格式:HTTP/1.1 200 ok
		2．设置状态码: setStatus(int sc)
	2．设置响应头: setHeader(String name，String value)
	3．设置响应体︰
		*使用步骤∶
			1。获取输出流
				*字符输出流：Printwriter getWriter()
				*字节输出流：ServletOutputStream getOutputStream()
			2．使用输出流，将数据输出到客户端浏览器
	*案例:
		1．完成重定向
			重定向:资源跳转的方式
			代码实现︰
				1．设置状态码为302
					response.setstatus (302);
				2.设置响应头location
					response.setHeader("location", "/day15/responseDemo2");
			简单的重定向方法
					response.sendRedirect("/day15/responseDemo2");
			*重定向的特点:redirect
				1．地址栏发生变化
				2．重定向可以访问其他站点(服务器)的资源
				3．重定向是两次请求。不能使用request对象来共享数据
			*转发的特点: forward
				1．转发地址栏路径不变
				2．转发只能访问当前服务器下的资源
				3．转发是一次请求，可以使用request对象来共享数据
			*forward和redirect区别

			*路径写法:
				1.路径分类
					1．相对路径：通过相对路径不可以确定唯一资源
						*如: ./index.html
						*不以/开头，以.开头路径
						*规则:找到当前资源和目标资源之间的相对位置关系
							./：当前目录
							../：后退一级目录
					2．绝对路径∶通过绝对路径可以确定唯一资源
						如: http://localhost/day15/responseDemo2 		/day15/responseDemo2
						以/开头的路径

						*规则:判断定义的路径是给谁用的?判断请求将来从哪儿发出
							*给客户端浏览器使用：需要加虚拟目录(项目的访问路径)
								*建议虚拟目录动态获取：request.getcontextPath()
								*<a> . <form> 重定向...
							*给服务器使用:不需要加虚拟目录
								转发路径

		2．服务器输出字符数据到浏览器
			*步骤:
				1．获取字符输出流  	Printwriter pw = response.getwriter();
				2、输出数据  			pw.write("你好");
			*注意:
				乱码问题:
					1.Printwriter pw = response.getwriter();获取的流的默认编码是ISO-8859-1
					2.设置该流的默认编码
					3.告诉浏览器响应体使用的编码
				简单的形式：(复杂形式的合体)
					//设置编码，是在获取流之前设置
					response.setcontentType( "text/html;charset=utf-8");  //设置流编码格式位utf-8 并且告诉浏览器用utf-8解码
				
				复杂形式：
					//获取流对象之前，设置流的默认编码: ISO-8859-1设置为:GBK 
					response.setCharacterEncoding( "utf-8" );   //设置流编码格式位utf-8
					//告诉浏览器，服务器发送的消息.体数据的编码。建议浏览器使用该编码解码
					response.setHeader( "content-type" , "text/html; charset=utf-8");   //告诉浏览器用utf-8解码
					//上一行是我自己设置为utf-8编码 下一行是告诉浏览器你也要用utf-8解码

		3．服务器输出字节数据到浏览器
			步骤:
				1.获取字节输出流
				2.输出数据

				response.setContentType( "text/htm1; charset=utf-8");	
				//1.获取字节输出流
					ServletOutputstream sos = response.getOutputStream( );
				//2.输出数据
					sos.write("你好".getBytes("utf-8"));

		4．验证码
			本质：图片
			目的：防止恶意表单注册

servletcontext对象︰
	1．概念∶代表整个web应用，可以和程序的容器(服务器)来通信
	2．获取︰
		1．通过request对象获取
			request.getservletcontext( );//getservletcontext函数是继承ServletRequest的
		2．通过Httpservlet获取
			this.getservletcontext();  //getservletcontext函数是继承GenericServlet的
		Servlet和ServletRequest家族都能获得ServletContext对象
	3.功能∶
		1．获取MIME类型∶
			*MIME类型:在互联网通佶过程中定义的一种文件数据类型
			*格式:大类型/小类型	text/html 	image/jpeg
			获取: String getMimeType(string file)
		2．域对象:共享数据
			1. setAttribute(string name,object value)
			2. getAttribute(string name)
			3. removeAttribute(string name)
			*Servletcontext对象范围:所有用户所有请求的数据
		3．获取文件的真实(服务器)路径
			方法:String getRealPath(String path)

案例:
	*文件下载需求:
		1．页面显示超链接
		2．点击超链接后弹出下载提示框
		3．完成图片文件下载
	分析:
		1，超链接指向的资源如果能够被浏览器解析，则在浏览器中展示，如果不能解析，则弹出下载提示框。不满足需求
		2．任何资源都必须弹出下载提示框
		3．使用响应头设置资源的打开方式:
			*content-disposition: attachment;filename=xxX
	*步骤∶
		1．定义页面，编辑超链接href属性，指向servlet，传递资源名称filename
		2．定义servlet
			1．获取文件名称
			2．使用字节输入流加载文件进内存
			3．指定response的响应头: content-disposition:attachment;filename=xXX4。将数据写出到response输出流

	//1.获取请求参数，文件名称
		String filename = request.getParameter("filename");

	//2.使用字节输入流加载文件进内存
		//2.1找到文件服务器路径
		ServletContext servletContext = this.getServletContext();
		String realPath = servletContext.getRealPath("/img/" + filename);

		//2.2用字节流关联
		FileInputStream fis = new FileInputstream(realPath);
		
	//3.设置response的响应头
		//3.1设置响应头类型:content-type
		String mimeType = servletContext.getNimeType(filename); 	//获取文件的mime类型
		response.setHeader("content-type" ,mimeType);

		//3.2设置响应头打开方式:content-disposition
		response.setHeader("content-disposition", "attachment;filename=" +filergme); attachment  附件

	//4.将输入流的数据写出到输出流中
		ServletOutputStream sos = response.getOutputStream();
		byte[] buff = new byte[ 1024 *8];
		int len = 0;
		while(( len = fis.read(buff))!= -1){
			sos.write(buff, off: o,len);
		}
	
##Cookie :
	1，概念:客户端会话技术，将数据保存到客户端
	2．快速入门:
		*使用步骤:
			1．创建cookie对象，绑定数据
				new cookie(string name,string value)
			2．发送cookie对象
				*response.addcookie(cookie cookie)
			3．获取cookie，拿到数据
				*cookie[]request.getcookies()
	3．实现原理
		*基于响应头set-cookie和请求头cookie实现
	4. cookie的细节
		1.一次可不可以发送多个cookie?
			*可以
			*可以创建多个cookie对象，使用response调用多次addcookie方法发送cookie即可。
		2. cookie在浏览器中保存多长时间?
			1．默认情况下，当浏览器关闭后，Cookie数据被销毁
			2．持久化存储:
				*setMaxAge(int seconds)
					1，正数:将Cookie数据写到硬盘的文件中。持久化存储。并指定cookie存活时间，时间到后，cookie文件自动失效
					2．负数:默认值
					3．零:删除cookie信息
		3. cookie能不能存中文?
			*在tomcat 8之前cookie中不能直接存储中文数据。
				*需要将中文数据转码---—般采用URL编码(%E3)
			*在tomcat 8 之后，cookie支持中文数据。
		4. cookie共享问题?
			1，假设在一个tomcat服务器中，部署了多个web项目，那么在这些web项目中cookie能不能共享?
				*默认情况下cookie不能共享
					* setPath(string path):设置cookie的获取范围。默认情况下，设置当前的虚拟目录
				*如果要共享，则可以将path设置为"/”
			2．不同的tomcat服务器间cookie共享问题?
				* setDomain(string path):如果设置一级域名相同，那么多个服务器之间cookie可以共享
					* setDomain(".baidu.com"),那么tieba.baidu.com和news.baidu.com中cookie可以共享
	5. Cookie的特点和作用
		1. cookie存储数据在客户端浏览器
		2．浏览器对于单个cookie 的大小有限制(4kb)以及对同一个域名下的总cookie数量也有限制(20个)
		
		*作用∶
			1. cookie一般用于存出少量的不太敏感的数据
			2.在不登录的情况下，完成服务器对客户端的身份识别

	6．案例︰记住上一次访问时间
		1.需求:
			1．访问一个servlet，如果是第一次访问，则提示:您好，欢迎您首次访问。
			2．如果不是第一次访问，则提示:欢迎回来，您上次访问时间为:显示时间字符串
		2．分析∶
			1．可以采用Cookie来完成
			2．在服务器中的servlet判断是否有一个名为lastTime的cookie
				1．有:不是第一次访问
					1．响应数据∶欢迎回来，您上次访问时间为:2018年6月10日11:50:20
					2．写回cookie : lastTime=2018年6月10日11:50:01
				2．没有:是第一次访问
					1．响应数据:您好，欢迎您首次访问
					2．写回Cookie : lastTime=2018年6月10日11:5O:01


先搞明白为什么会乱码，为什么要转码：
在tomcat 8 之前，cookie中不能直接存储中文数据。需要将中文数据转码，一般采用URL编码(%E3)。
在tomcat 8 之后，cookie支持中文数据。特殊字符还是不支持（比如空格），建议使用URL编码存储，URL解码解析。

编码解码前后字符如下表所示：

编码前	十进制数字、汉字
编码后	十六进制数字、英文
解码前	十六进制数字、英文
解码后	十进制数字、汉字
nowTime = URLEncoder.encode(nowTime, "utf-8");   //编码
lastTime = URLDecoder.decode(lastTime, "utf-8"); //解码

解释：tomcat8之前cookie中不能存放非ascll码范围内的字符  
	  tomcat8之后cookie中能存放中文字符 但是不能存放空格之类的特殊字符 如果要存放特殊字符的话
		就必须把要存的字符串先通过URLEncoder编码，(这种编码和get方式url的编码一样，中文会变成%加两个16进制数字)
		这样才能传输否则会报服务器错误，接收到cookie的时候就需要通过URLDecoder解码才能得到原来的字符串


##JSP:入门学习
	1．概念:
		Java server Pages : Jiava服务器端页面
			*可以理解为:一个特殊的页面，其中既可以指定定义html标签，又可以定义java代码
			*用于简化书写!! !
	2．原理
		jSP本质上就是一个servlet
	3.JSP的脚本:JSP定义Java代码的方式
		1.<% 代码 %>：定义的java代码，在service方法中。service方法中可以定义什么，该脚本中就可以定义什么。
		2.<%! 代码 %>：定义的java代码，在jsp转换后的java类的成员位置。
		3.<%= 代码 %>：定义的java代码，会输出到页面上。输出语句中可以定义什么，该脚本中就可以定义什么。
	4.JSP的内置对象:
		*在jsp页面中不需要获取和创建，可以直接使用的对象
		*jsp-共有9个内置对象。
		*今天学习3个:
			request
			response
			out:字符输出流对象。可以将数据输出到页面上。和response.getwriter()类似
				response.getwriter()和out.write(()的区别:
				*在tomcat服务器真正给客户端做出响应之前，会先找response缓冲区数据，再找out缓冲区数据。
				*response.getwriter()数据输出永远在out.write()之前

##Session :
	补：开始访问服务器时，服务器会在内存创建一个Session对象并且有一个JSessionID，响应会携带一个set-cookie：JSESSIONID=***的
		响应头信息（也就是添加了一个Cookie），然后这个cookie信息就会保存在浏览器，之后的每次请求都会在请求头发送这个cookie信息，
		服务端可以通过request.getSession()获得这个Session，然后通过Session.getAttribute()或setAttribute()来交换信息.
		不同浏览器保存的SessionID不同，也就是说服务器为每个浏览器创建一个Session对象.
		浏览器关闭后再打开获取的Session和上次获取的不是同一个，如果希望是同一个，可以创建cookie,键为JSESSIONID，设置最大存活时间
			Cookie c = new Cookie("JSESSIONID", session.getId()); 
			c.setMaxAge(60 * 60);
			response.addcookie(c);
		原理：当请求到来时，服务端发现请求中有一个Cookie：SESSIONID=***，这种情况下，就不会再创建session对象了，用的还是原来的session
		
	·服务器会给每一个用户(浏览器）创建一个Seesion对象;
	。一个Seesion独占一个浏览器，只要浏览器没有关闭，这个Session就存在;
	·用户登录之后，整个网站它都可以访问!-->保存用户的信息;保存购物车的信息.....
	session在浏览器打开之后就存在了

	1．概念∶服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中。HttpSession
	2.快速入门∶
		1．获取Httpsession对象∶
			Httpsession session = request.getsession();
		2．使用Httpsession对象:
			object getAttribute(string name)
			void setAttribute(string name，object value)
			void removeAttribute(string name)
	3．原理
		session的实现是依赖于cookie的。
	4、细节:
		1，当客户端关闭后，服务器不关闭，两次获取session是否为同一个?
			默认情况下。不是。
			* 如果需要相同，则可以创建cookie,键为JSESSIONID，设置最大存活时间，让cookie持久化保存。
				Cookie c = new Cookie("JSESSIONID", session.getId());
				c.setMaxAge(60 * 60);
				response.addcookie(c);
		2．客户端不关闭，服务器关闭后，两次获取的session是同一个吗?
			不是同一个，但是要确保数据不丢失。tomcat自动完成以下工作
			session的钝化;
				在服务器正常关闭之前，将session对象系列化到硬盘上
			session的活化:
				在服务器信动后，将session文件转化为内存中的session对象即可
		3. session什么时候被销毁?
			1．服务器关闭
			2. session对象调用invalidate() 。
			3. session默认失效时间30分钟
				选择性配置修改
				<session-config>
					<session-timeout>30</session-timeout>
				</ session-config>
	5. session的特点
			1. session用于存储一次会话的多次请求的数据，存在服务器端
			2. session可以存储任意类型，任意大小的数据
		session与cookie的区别:
			1. session存储数据在服务器端，Cookie在客户端
			2. session没有数据大小限制,Cookie有
			3. session数据安全，Cookie相对于不安全


##JSP:
1．指令
	*作用:用于配置JSP页面，导入资源文件
	*格式:
		<%@ 指令名称属性名1=属性值1属性名2=属性值2... %>
	*指令分类∶
		1.page:配置]SP页面的
			*contentType :等同于response.setContentType()
				1，设置响应体的mime类型以及字符集
				2，设置当前jsp页面的编码（只能是高级的IDE才能生效，如果使用低级工具，则需要设置pageEncoding属性设置当前页面的字符集)
				<%@page contentType="text/html;charset=UTF-8" language="java"%>
			*import :导包
				<%@page import="java.uti1.List”%>
			*errorPage:当前页面发生异常后，会自动跳转到指定的错误页面
				<%@page errorPage="500.jsp”%>
			*isErrorPage:标识当前也是是否是错误页面。
				*true:是，可以使用内置对象exception
				*false :否。默认值。不可以使用内置对象exception
		2. include:页面包含的。导入页面的资源文件
			*<%@include file="top.jsp"%>  //导入top.jsp文件中的资源 资源复用 
		3. taglib:导入资源
			*<%@taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
			*prefix:前缀，自定义的
2．注释:
	1. html注释:
		<! -- -->:只能注释html代码片段
	2.jsp注释:推荐使用
		<%-- --%>:可以注释所有

3．内置对象
	*在jsp页面中不需要创建，直接使用的对象
	*—共有9个:
	变量名							真实类型							作用范围
	*pagecontext				Pagecontext			当前页面共享数据，还可以获取其他八个内置对象
	*request 				HttpservletRequest			一次请求访问的多个资源(转发)
	*session 					Httpsession 				一次会话的多个请求间
	*application 				servletcontext 				所有用户间共享数据
	
	*response 				HttpservletResponse 				   响应对象
	*page 							object 				当前页面(Servlet)的对象this
	*out 							Jspwriter 				输出对象，数据输出到页面上
	*config 					servletconfig 				servlet的配置对象
	*exception 					Throwable 							异常对象


##MVC :开发模式
	1. jsp演变历史
		1．早期只有servlet，只能使用response输出标签数据，非常麻烦
		2后来又jsp，简化了servlet的开发，如果过度使用jsp，在jsp中即写大量的java代码，有写html表，造成难于维护，难于分工协作
		3．再后来，java的web开发，借鉴mvc开发模式，使得程序的设计更加合理性
	2.MVC :
		1.M :Model，模型。JavaBean
			* 完成具体的业务操作，如:查询数据库，封装对象
		2. v : view，视图。JSP
			*展示数据
		3. C : controller，控制器。Servlet
			*获取用户的输入
			*调用模型
			*将数据交给视图进行展示
	*优缺点∶
		1。优点:
			1．耦合性低，方便维护，可以利于分工协作
			2．重用性高
		2．缺点:
			1．使得项目架构变得复杂，对开发人员要求高
##EL表达式
	1.概念∶Expression Language 表达式语言
	2.作用:替换和简化jsp页面中java代码的编写
	3．语法∶${表达式}
	4．注意︰
		*jsp默认支持el表达式的。如果要忽略el表达式
			1，设置jsp中page指合中: isELIgnored="true”忽略当前jsp页面中所有的el表达式
			2.\${表达式}:忽略当前这个el表达式
	5.使用:
		1．运算
			运算符︰
				1.算数运算符：+  -  *  /(div)  %(mod)
				2.比较运算符：>  <  >=  <=  == !=
				3.逻辑运算符：&&(and)   ||(or)  !(not)
				4．空运算符:empty
					*功能:用于判断字符串、集合、数组对象是否为null或者长度是否为0
					*${empty list}
					{not empty list} 判断不为null并且长度大于0

		2.获取值
			1. el表达式只能从域对象中获取值
			2．语法︰
				1．${域名称.键名}∶从指定域中获取指定键的值
					域名称:
						1. pageScope --> pageContext
						2. requestScope --> request
						3. sessionScope -->session
						4. applicationScope --> application (ServletContext)
					*举例:在request域中存储了name=张三
					*获取︰${requestscope.name}
				2．${键名}︰表示依次从最小的域中查找是否有该键对应的值，直到找到为止。
				3．获取对象、List集合、Map集合的值
					1.对象∶${域名称.键名.属性名}
						*本质上会去调用对象的getter方法   必须有对应的get方法 并且方法名要和属性名或键名一样
					2. List集合：${域名称.键名[索引]}
					3. Map集合∶
						*${域名称.键名.key名称}
						*${域名称.键名["key名称"]}
			3。隐式对象∶
				*el表达式中有11个隐式对象
				*pagecontext :
					获取jsp其他八个内置对象
						*${pagecontext.request.contextPath}:动态获取虚拟目录


##JSTL
1，概念∶Javaserver Pages Tag Library JSP标准标签库
	*是由Apache组织提供的开源的免费的jsp标签  <标签>
2．作用:用于简化和替换jsp页面上的java代码
3.使用步骤︰
	1．导入jstl相关jar包
	2．引入标签库: taglib指今∶<%@taglib %>
	3．使用标签
4．常用的JSTL标签
	1. if:相当于java代码的if语句
		1．属性︰
			*test 必须属性，接受boolean表达式
				*如果表达式为true，则显示if标签体内容，如果为false，则不显示标签体内容
				*—般情况下, test属性值会结合el表达式一起使用
				<c:if test="true">
					<h1>我是真...</h1>
				</c:if>

		2．注意∶
			*c:if标签没有else情况，想要else情况，则可以在定义一个c:if标签
	2. choose:相当于java代码的switch语句
		1。使用choose标签声明相当于switch声明
		2．使用when标签做判断相当于case
		3．使用otherwise标签做其他情况的声明相当于default
		<c:choose>
			<c:when test="${number == 1}">星期一</c:when>
			<c:when test="${number == 2}">星期二</c:when>
			<c:when test="${number == 3}">星期三</c:when>
			<c:when test="${number == 4}">星期四</c:when>
			<c:when test="${number == 5}">星期五</c:when>
			<c:when test="${number == 6}">星期六</c:when>
			<c:when test="${number == 7}">星期天</c:when>
			<c:otherwise>数字输入有误</c:otherwise>
		</c:choose>

	3. foreach:相当于java代码的for语句
		1．完成重复的操作
			for(int i =T; i < 10; i ++){
			}
			*属性:
				begin:开始值
				end:结束值
				var: 临时变量
				step:步长
				varStatus:循环状态对象
					index:容器中元素的索引，从0开始
					count:循环次数，从1开始
		2．遍历容器
			List<User> list;
			for(User user : list){
			}
			*属性:
				items:容器对象
				var:容器中元素的临时变量
				varStatus:循环状态对象
					index:容器中元素的索引，从0开始
					count:循环次数，从1开始
				<c:forEach items="${list}" var="str" varStatus="s">
					${s.index} ${s.count} ${str}<br>
				</c:forEach>

##三层架构:软件设计架构
	1．界面层(表示层)∶用户看的得界面。用户可以通过界面上的组件和服务器进行交互
	2．业务逻辑层︰处理业务逻辑的。
	3．数据访问层:操作数据存储文件。

#Filter :过滤器
	1.概念
		*生活中的过滤器︰净水器,空气净化器，土匪、
		*web中的过滤器︰当访问服务器的资源时，过滤器可以将请求拦截下来，完成一些特殊的功能。
		*过滤器的作用∶
			*一般用于完成通用的操作。如∶登录验证、统一编码处理、敏感字符过滤...

	2.快速入门:
		1．步骤∶
			1．定义一个类，实现接口Filter
			2．复写方法
			3．配置拦截路径
				1. web.xml
				2．注解
		2．代码:
			@WebFilter("/*") //这个过滤器针对所有页面
			public class FilterDemo1 implements Filter {
			    @Override
			    public void init(FilterConfig filterConfig) throws ServletException {
			        Filter.super.init(filterConfig);
			    }

			    @Override
			    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
			        System.out.println("执行了s");
			        //放行   可以访问改页面
			        filterChain.doFilter(servletRequest, servletResponse);
			    }

			    @Override
			    public void destroy() {
			        Filter.super.destroy();
			    }
			}


	3．过滤器细节:
		1. web.xml配置
			<filter>
				<filter-name>demo1</filter-name>
				<filter-class>cn.itcast.web.filter.FilterDemo1</filter-class
			</filter>
			<filter-mapping>
				<filter-name>demo1</filter-name>   
				<!--拦截路径-->
				<url-pattern>/*</url-pattern>
			</filter-mapping>
		2．过滤器执行流程
			1．执行过滤器
			2．执行放行后的资源
			3．回来执行过滤器放行代码下边的代码
		3．过滤器生命周期方法
			1. init:在服务器后动后，会创建Filter对象，然后调用init方法。只执行一次。用于加载资源
			2. doFilter:每一次请求被拦截资源时，会执行。执行多次
			3. destroy:在服务器关闭后，Filter对象被销毁。如果服务器是正常关闭，则会执行destroy方法。只执行一次。用于释放资源
		4．过滤器配置详解
			拦截路径配置:
				1．具体资源路径:/index.jsp  只有访问index.jsp资源时，过滤器才会被执行
				2．拦截目录:/user/*访问/user下的所有资源时，过滤器都会被执行
				3．后缀名拦截: *.jsp访问所有后缀名为jsp资源时，过滤器都会被执行
				4．拦截所有资源︰/*访问所有资源时，过滤器都会被执行
			拦截方式配着:资源被访问的方式
				*注解配置∶
					*设置dispatcherTypes属性
						1.REQUEST:默认值。浏览器直接请求资源   只有直接请求才会被拦截
						2.FORWARD:转发访问资源   只有转发访问才会被拦截
						3.INCLUDE:包含访问资源
						4.ERROR:错误跳转资源
						5.ASYNC:异步访问资源
				web . xml配置
					*设置<dispatcher></dispatcher>标签即可 该标签在<filter-mapping>标签下  可以取dispatcherTypes的5个值
		5．过滤器链(配置多个过滤器)
			*执行顺序:如果有两个过滤器:过滤器1和过滤器2
				1．过滤器1
				2．过滤器2
				3．资源执行
				4．过滤器2
				5．过滤器1

			*过滤器先后顺序问题∶
				1．注解配置∶按照类名的字符串比较规则比较，值小的先执行
					*如:AFilter和BFilter,AFilter就先执行了。
				2. web.xml配置:<filter-mapping>谁定义在上边，谁先执行
##Listener :监听器
	*概念: web的三大组件之一。
		*事件监听机制
		*事件:件事情
		*事件源:事件发生的地方
		*监听器:一个对象
		*注册监听∶将事件、事件源、监听器绑定在一起。当事件源上发生某个事件后，执行监听器代码
	*ServletcontextListener:监听servletcontext对象的创建和销毁
		*void contextDestroyed(ServletContextEvent sce) : servletContext对象被销毁之前会调用该方法
		*void contextInitialized(servletContextEvent sce) : servletContext对象创建后会调用该方法
	*步骤∶
		1、定义一个类,实现servletcontextListener接口
		2．复写方法
		3．配置
			1. web.xml
				<listener>
					<listener-class>cn.itcast.web.listener.contextLoaderListener</listener-class>
				</listener>
				*指定初始化参数：
					<context-param>
						<param-name>contextConfigLocation</param-name>
						<param-va1ue>/WEB-INF/classes/applicationContext.xml</param-va1ue>
					</context-param>
					//加找资源文件
				在配置文件指定给初始化参数后，可以在contextInitialized方法中获取到初始化参数对印的值
				这样做可以在服务器启动时做一些事情，这里的例子是将一个配置文件加载进内存.
				//1.获取ServletContext对象
					ServletContext servletContext = servletContextEvent.getServletContext();
				// 2.加资源文件
					String contextConfigLocation = servletContext.getInitParameter("contextConfigLocation");
				/ /3.获取真实路径
					String realPath = servletContext.getRealPath(contextConfigLocation);
				// 4.加找进内存
				try{
					FileInputStream fis = new FileInputStream(eealPath);
					System.out.println(fis);
				}catch (Exception e){
					e. printstackTrace();
				}

			2．注解:
				@Weblistener




html：
	*表单项标签︰
		*input :可以通过type属性值，改变元秦展示的样式
			type属性:
				*text:文本输入框,默认值
					*placeholder:指定输入框的提示信息，当输入框的内容发生变化，会自动清空提示信息
				*password:密码输入框
				*radio:单选框
					*注意:
						1，要想让多个单选框实现单选的效果，则多个单选框的name属性值必须一样。
						2，一般会给每一个单选框提供value属性，指定其被选中后提交的值
						3. checked属性，可以指定默认值
				*checkbox:复选框
					*注意:
						1.一般会给每一个单选框提供value属性，指定其被选中后提交的值
						2. checked属性，可以指定默认值
				*file:文件选择框
				*hidden·隐藏域，用于提交一些信息。
				*按钮:
					*submit:提交按钮。可以提交表单
					*button:普通按钮
					*image :图片提交按钮
						*src属性指定图片的路径

				*label:指定输入项的文字描述信息
					注意∶ <label for="对应的id属性"></label>
						* label的for属性一般会和 input的 id属性值对应。如果对应了，则点击label区域，会让input输入框获取焦点。
		*select: 下拉列表
			*子元素: option，指定列表项
		*textarea :文本域
			*cols :指定列数，每一行有多少个字符
			*rows :默认多少行。

##CSS :页面美化和布局控制
	1．概念: cascading style sheets层叠样式表
		*层叠:多个样式可以作用在同一个html的元泰上，同时生效
	2．好处:
		1．功能强大
		2．将内容展示和样式控制分离
			*降低耦合度。解耦
			*让分工协作更容易
			*提高开发效率

	3. css的使用: css与html结合方式
		1．内联样式
			*在标签内使用style属性指定css代码
			*如:<div style="color : red;">hello css</div>
		2．内部样式
			*在head标签内，定义style标签，style标签的标签体内容就是css代码
			*如:
				<style>
					div{
						color: blue;
					}
				</style>
				<div>hello css</div>
		3．外部样式
			1．定义css资源文件。
			2．在head标签内，定义link标签，引入外部的资源文件
			*如:
				*a.css文件:
					div{
						color:green;
					}
				<link rel="stylesheet" href="css/a.css">
			*注意︰
				*1,2,3种方式css作用范围越来越大
				*1方式不常用，后期常用2,3
				*第3种格式可以写为∶
					<style>
						@import "css/a.css";
					</style>

	4. css语法︰
		*格式:
			选择器{
				属性名1:属性值1;
				属性名2:属性值2;
			}
		*选择器:筛选具有相似特征的元素
		*注意∶
			*每一对属性需要使用;隔开，最后一对属性可以不加;
	5．选择器∶筛选具有相似特征的元素
		*分类︰
			1.基本选择器
				1. id选择器∶选择具体的id属性值的元秦.建议在一个html页面中id值唯一
					*语法:#id属性值{}
				2．元素选择器∶选择具有相同标签名称的元素
					*语法:标签名称{}
					*注意:id选择器优先级高于元素选择器
				3．类选择器∶选择具有相同的class属性值的元素。
					*语法:.class属性值{}
					*注意:类选择器选择器优先级高于元素选择器
					id > class > 标签
			2．扩展选择器
				1．选择所有元素∶
					*语法:*{}
				2．并集选择器∶
					*选择器1,选择器2{}
				3．子选择器∶筛选选择器1元秦下的选择器2元素
					*语法:选择器1 选择器2{}
				4．父选择器:筛选选择器2的父元秦选择器1
					*语法∶选择器1>选择器2{}
				5.属性选择器∶选择元素名称，属性名=属性值的元素
					*语法:元素名称[属性名="属性值"]{}
						input[type="text"]{}
				6．伪类选择器∶选择一些元素具有的状态
					*语法:元素:状态
					*如: <a>
						*状态︰
							*link:初始化的状态         	//还没点时的状态
							*visited:被访问过的状态		//点完后的状态
							*active :正在访问状态		//点击还没松手的状态
							*hover :鼠标悬浮状态		//鼠标放上去变成小手但未点击时的状态
						a:link{}
	6．属性
		1．字体、文本
			*font-size :字体大小
			*color :文本颜色
			*text-align :对其方式
			*line-height :行高
		2．背景
			*background :
		3．边框
			*border :设置边框，符合属性
		4．尺寸
			*width :宽度
			*height :高度
		5．盒子模型:控制布局
			*margin :外边距
			*padding :内边距
				*默认情况下内边距会影响整个盒子的大小
				*box-sizing: border-box;设置盒子的属性，让width和height就是最终盒子的大小
			*float :浮动
				*left
				*right

##Javascript :
	*概念:一门客户端脚本语言
		*运行在客户端浏览器中的。每一个浏览器都有Javascript的解析引擎
		*脚本语言:不需要编译，直接就可以被浏览器解析执行了
	*功能∶:
		*可以来增强用户和html页面的交互过程，可以来控制html元素，让页面有一些动态的效果，增强用户的体验。
	Javascript发展史︰
		1，1992年，Nombase公司，开发出第一门客户端脚本语言，专门用于表单的校验。命名为∶C--，后来更名为:scriptEase
		2.1995年，Netscape(网景)公司，开发了一门客户端脚本语言:LiveScript。后来，请来SUN公司的专家，修改Livescript,命名为JavaScript
		3. 1996年，微软抄袭Javascript开发出JScript语言
		4.1997年，ECNA(欧洲计算机制造商协会)，制定出客户端脚本语言的标准:ECNAScript，就是统一了所有客户端脚本语言的编码方式。
			*Javascript = ECMAScript + Javascript自己特有的东西(BOM+DOM)
	*ECMAScript:客户端脚本语言的标准
		1，基本语法︰
			1.html结合方式
				1．内部s :
				*定义<script>,标签体内容就是js代码
				2．外部S∶
					*定义<script>，通过src属性引入外部的js文件
			*注意:
				1. <script>可以定义在html页面的任何地方。但是定义的位置会影响执行顺序。
				2. <script>可以定义多个。
		2．注释
			1.单行注释://注释内容
			2.多行注释:/*注释内容*/
		3．数据类型:
			1．原始数据类型(基本数据类型):
				1. number :数字。整数/小数/NaN(not a number 一个不是数字的数字类型)
				2. string:字符串。字符串"abc" "a" 'abc'
				3. boolean: true和false
				4. null:一个对象为空的占位符
				5. undefined:未定义。如果一个变量没有给初始化值，则会被默认赋值为undefined
			2．引用数据类型:对象
		4.变量
			*变量:—小块存储数据的内存空间
			*java语言是强类型语言，而Javascript是弱类型语言。
				*强类型∶在开辟变量存储空间时，定义了空间将来存储的数据的数据类型。只能存储固定类型的数据
				*弱类型:在开辟变量存储空间时，不定义空间将来的存储数据类型，可以存放任意类型的数据。
			*语法:
				var变量名=初始化值;
			*typeof运算符:获取变量的类型。
				*注:null运算后得到的是object
		5．运算符
			1.一元运算符:只有一个运算数的运算符
				++,-- ,+(正号)
				*++ --:自增(自减)
						*++(--） 在前，先自增(自减)，再运算
						*++(--） 在后，先运算，再自增(自减)
				*+(-):正负号
				*注意:在JS中，如果运算数不是运算符所要求的类型，那么js引擎会自动的将运算数进行类型转换
					*其他类型转number :
						*string转number:按照字面值转换。如果字面值不是数字，则转为NaN(不是数字的数字)
						*boolean转number : true转为1,false转为0
			2．算数运算符
				+ - * / %...
			3．赋值运算符
				=+= -+...
			4.比较运算符
				> < >= <= == ===(全等于)
				*比较方式
					1．类型相同:直接比较
						*字符串:按照字典顺序比较。按位逐一比较，直到得出大小为止。
					2．类型不同:先进行类型转换，再比较
						*===:全等于。在比较之前，先判断类型，如果类型不一样，则直接返回false
			5，逻辑运算符
				&& || !
				*其他类型转boolean :
					1. number :0或NaN为假，其他为真
					2. string:除了空字符串("")，其他都是true
					3. nul1&undefined:都是false
					4. 对象:所有对象都为true
			6．三元运算符
				?:表达式
				var a = 3;var b = 4;
				var c = a > b ?1∶0;
				*语法∶
					*表达式?值1:值2;
					*判断表达式的值，如果是true则取值1，如果是false则取值2;
		6．流程控制语句∶
			1. if...else. . .
			2. switch:
				在java中, switch语句可以接受的数据类型: byte int shor char ,枚举(1.5) ,string(1.7)
				*在Js中, switch语句可以接受任意的原始数据类型
			3. while
			4. do. ..while
			5. for
		7.Js特殊语法:
			1．语句以;结尾，如果一行只有一条语句则;可以省略（不建议)
			2．变量的定义使用var关键字，也可以不使用
				*用var定义的变量是局部变量
				*不用var定义的变量是全局变量(不建议)

	基本对象∶
		1.Function:函数(方法)对象
			1.创建:
				1. var fun = new Function(形式参数列表,方法体);//忘掉吧
				2.
					function 方法名称(形式参数列表){
						方法体
					}
				3.
					var方法名=function(形式参数列表){
						方法体
					}
			2．方法:
			3．属性:
				length:代表形参的个数
			4．特点∶
				1．方法定义是，形参的类型不用写,返回值类型也不写。
				2．方法是一个对象，如果定义名称相同的方法，会覆盖
				3．在Js中，方法的调用只与方法的名称有关，和参数列表无关
				4．在方法声明中有一个隐藏的内置对象（数组)，arguments,封装所有的实际参数
			5．调用:
				方法名称(实际参数列表);
		2. Array:数组对象
			1.创建︰
				1. var arr = new Array(元素列表);
				2. var arr = new Array (默认长度);
				3. var arr =[元素列表];
			2．方法
				join(参数):将数组中的元素按照指定的分隔符拼接为字符串
				push()向数组的末尾添加一个或更多元素，并返回新的长度。
			3．属性
				length:数组的长度
			4．特点∶
				1.Js中，数组元素的类型可变的。
				2.Js中，数组长度可变的。
		3.Boolean
		4. Date :日期对象
			1。创建︰
				var date = new Date();
			2。方法︰
				toLocalestring():返回当前date对象对应的时间本地字符串格式
				getTime():获取毫秒值。返回当前如期对象描述的时间到197o年1月1日零点的毫秒值差
		5. Math :数学对象
			1．创建:
				*特点:Math对象不用创建，直接使用。 Math.方法名();
			2．方法:
				random():返回0~ 1 之间的随机数。含0不含1 
				ceil(x)∶对数进行上舍人。
				floor(x):对数进行下舍人。
				round(x):把数四舍五入为最接近的整数。
			3．属性∶
				PI
		6.Number
		7.String
		8. RegExp︰正则表达式对象
			1．正则表达式:定义字符串的组成规则。
				1．单个字符:[]
					如: [a] [ab] [a-zA-Z0-9_]
					*特殊符号代表特殊含义的单个字符:
						\d:单个数字字符[0-9]
						\w:单个单词字符[a-zA-Z0-9_]
				2．量词符号∶
					?:表示出现0次或1次
					*:表示出现0次或多次
					+︰出现1次或多次
					{m,n}:表示m<=数量<= n
						*m如果缺省:{,n}:最多n次
						*n如果缺省:{m,}最少m次
				3.开始结束符号
					*^:开始
					*$:结束
			2。正则对象∶
				1．创建
					1. var reg = new RegExp("正则表达式");
					2. var reg = /正则表达式/;
				2．方法
					1. test(参数):验证指定的字符串是否符合正则定义的规范
		9.Global对象：
			1．特点:全局对象，这个Global中封装的方法不需要对象就可以直接调用。方法名();
			2．方法:
				encodeURI() : url编码
				decodeURI() : url解码
				
				encodeURIComponent() : url编码  编码的字符更多 可以编码除汉字以外其他字符
				decodeURIComponent() : url解码
				
				parseInt():将字符串转为数字
					逐一判断每一个字符是否是数字，直到不是数字为止，将前边数字部分转为number
					
				isNaN():判断一个值是否是NaN
					*NaN六亲不认，连自己都不认。NaN参与的==比较全部问false
				eval():计算 JavaScript字符串，并把它作为脚本代码来执行。
			3.URL编码
				传智播客=%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2
				
##DOM简单学习:为了满足案例要求
	*功能:控制html文档的内容
	*获取页面标签(元素)对象:Element
		*document.getElementById("id值"):通过元素的id获取元秦对象
		
	*操作Element对象∶
		1．修改属性值:
			1．明确获取的对象是哪一个?
			2．查看API文档，找其中有哪些属性可以设置
		2．修改标签体内容︰
			*属性:innerHTML
			1．获取元素对象
			2．使用innerHTML属性修改标签体内容 
			
##事件简单学习
	*功能:某些组件被执行了某些操作后，触发某些代码的执行。
	*如何绑定事件
		1．直接在html标签上，指定事件的属性(操作)，属性值就是js代码
			1.事件: onclick---单击事件
		2．通过js获取元素对象，指定事件属性，设置一个函数
		*代码:
			<body>
				<img id="light" src="img/off.gif" onclick="fun();">  在html标签中写onclick时只能用引号加javascript代码 onclick="script"
				<img id="light2" src="img/off.gif">					在javascript中写onclick时只能用函数对象 onclick=fun
				<script>											
					function fun(){
						alert('我被点了');
						alert('我又被点了');
					}
					function fun2(){
						alert( '咋老点我?');
					}
					//1.获取light2对象
					var light2 = document.getElementById( "light2" );
					//2.绑定事件
					light2.onclick = fun2;
				</script>
			</body>
			
#BOM:
	1.概念∶Browser object Model 浏览器对象模型
		*将浏览器的各个组成部分封装成对象。
	2．组成:
		*Window :窗口对象
			1．创建
			2．方法
				1.与弹出框有关的方法:
					alert()显示带有一段消,息和一个确认按钮的警告框。  //警示 提示
					confirm()显示带有一段消息以及确认按钮和取消按钮的对话框。 //证实
						*如果用户点击确定按钮,则方法返回true
						*如果用户点击取消按钮,则方法返回false
					prompt()显示可提示用户输入的对话框。	//提醒(某人说话)
						*返回值:获取用户输入的值
				2．与打开关闭有关的方法:
					close(）关闭浏览器窗口。
						*谁调用我,我关谁
					open()打开一个新的浏览器窗口
						*返回新的window对象
				3．与定时器有关的方式
					setTimeout()在指定的毫秒数后调用函数或计算表达式。  
					除非是在浏览器关闭文档之前调用document.write，否则当前页面都会被清除。
						*参数:
							1. js代码或者方法对象
							2．毫秒值
						*返回值:唯—标识,用于取消定时器
					clearTimeout()取消由setTimeout()方法设置的 timeout。
					setInterval()按照指定的周期（以毫秒计）来调用函数或计算表达式。
					clearInterval()取消由setInterval()设置的timeout。
			3．属性:
				1．获取其他BOM对象:
					history	location	Navigator	screen 
				2．获取DOM对象
					document
			4．特点
				*window对象不需要创建可以直接使用window使用。window .方法名();
				*window引用可以省略。方法名();

		*Location :地址栏对象
			1．创建(获取)∶
				1. window.location
				2. location
			2．方法∶
				reload()重新加载当前文档。刷新
			3．属性
				href设置或返回完整的URL。
		*History :历史记录对象
			1．创建(获取)∶
				1. window.history
				2. history
			2．方法︰
				*back()加载history列表中的前一个URL。
				*forward()加载history列表中的下一个URL。
				*go(参数)加载history列表中的某个具体页面。
					*参数:
						*正数:前进几个历史记录
						*负数:后退几个历史记录
			3．属性:
				*length返回当前窗口历史列表中的 URL数量。
		*Navigator :浏览器对象
		*Screen :显示器屏幕对象
		

##DOM :
	概念:Document obiect Model文档对象模型
		*将标记语言文档的各个组成部分，封装为对象。可以使用这些对象，对标记语言文档进行cRUD的动态操作
	w3C DOM标准被分为3个不同的部分︰
		*核心DOM -针对任何结构化文档的标准模型
			*Document :文档对象
				1．创建(获取):在html dom模型中可以使用window对象来获取
					1. window.document
					2. document
				2．方法︰
					1．获取Element对象:
						1. getElementById()︰根据id属性值获取元秦对象。id属性值一般唯一
						2. getElementsByTagName():根据元秦名称获取元秦对象们。返回值是一个数组
						3. getElementsByclassName():根据class属性值获取元秦对象们。返回值是一个数组
						4. getElementsByName():根据name属性值获取元秦对象们。返回值是一个数组
					2．创建其他DOM对象︰
						createAttribute(name)
						createcomment()
						createElement()
						createTextNode()
				3．属性

			*Element :元素对象
				1．获取/创建︰通过document来获取和创建
				2．方法︰
					1. removeAttribute() :删除属性
					2. setAttribute():设置属性

			*Attribute :属性对象
			*Text :文本对象
			*comment:注释对象
			*Node :节点对象，其他5个的父对象
				*特点:所有dom对象都可以被认为是一个节点
				*方法:
					*CRUD dom树:
						*appendChild():向节点的子节点列表的结尾添加新的子节点。
						*removeChild() :删除(并返回)当前节点的指定子节点。
						*replacechild():用新节点替换一个子节点。
				*属性:
					parentNode返回节点的父节点。
					lastChild和lastElementChild的区别  csdn
				补充：超链接功能:
					1.可以被点击:样式
					2.点击后跳转到href指定的url
					需求:保留1功能，去掉2功能   实现: href="javascript : void(e)"

		*HTML DOM -针对HTML文档的标准模型
			1．标签体的设置和获取:innerHTML
				<script >
					var div = document.getElementById("div1");
					var innerHTML = div.innerHTML;
					// alert(innerHTML);
					// div标签中替换一个文本输入框
					// div.innerHTML ="<input type='text'>";
					// div标签中追加一个文本输入框
					div.innerHTML += "<input type='text'>";
				</script>
			2．使用html元素对象的属性  查API
			3. 控制样式
				1．使用元素的style属性来设置
					如∶
						//修改样式方式1
						div1.style.border = "1px solid red";
						div1.style.width = "200px" ;
						//font-size--> fontsize  
						div1.style.fontSize = "20px";
				2．提前定义好类选择器的样式，通过元素的className属性来设置其class属性值。
		*XML DOM -针对XML文档的标准模型


##事件监听机制:
	*概念:某些组件被执行了某些操作后，触发某些代码的执行。
	*事件:某些操作。如:单击，双击，键盘按下了，鼠标移动了*事件源:组件。如:按钮文本输入框...
	*监听器:代码。
	*注册监听∶将事件，事件源，监听器结合在一起。当事件源上发生了某个事件，则触发执行某个监听器代码。
	
	*常见的事件∶
		1、点击事件:
			1. onclick:单击事件
			2. ondblclick :双击事件
		2.焦点事件
			1. onblur:失去焦点
			2. onfocus:元素获得焦点。
		3。加载事件∶
			1. onload :一张页面或一幅图像完成加载。
				window.onload=function(){}  窗口加载完毕了再执行函数
		4。鼠标事件:
			1. onmousedown 	鼠标按钮被按下。
				*定义方法时，定义一个形参,接受event对象。
				*event对象的button属性可以获取鼠标哪个按钮键被点击了。 event.button 获取鼠标按键对应的数字
			2. onmouseup	鼠标按键被松开。
			3. onmousemove	鼠标被移动。
			4. onmouseover	鼠标移到某元秦之上。
			5. onmouseout 	鼠标从某元秦移开。
		5．键盘事件:
			1. onkeydown某个键盘按键被按下。
				event.keyCode  获取键盘按键对应的数字（ASCII码）
			2. onkeyup某个键盘按键被松开。
			3. onkeypress某个键盘按键被按下并松开。
		6．选择和改变
			1. onchange域的内容被改变。
			2. onselect文本被选中。
		7．表单事件∶
			1. onsubmit确认按钮被点击。
				*可以阻止表单的提交
				*方法返回false则表单被阻止提交。
					<body>                 下面这里的解释：onsubmit=""  这个后面是一个函数 引号里面写的是函数内容 所以要return
						<form action="#" onsubmit="return checkForm()">
							<input name="username" id="name">
							<input type="submit" value="提交">
						</form>
					</body>
					<script>
						function checkForm() {
							return false;
						}
					</script>
					或
					<body>
						<form action="#">
							<input name="username" id="name">
							<input type="submit" value="提交">
						</form>
					</body>
					<script>
						document.getElementsByTagName("form")[0].onsubmit = function() {
							return true;
						}
					</script>
			2. onreset重置按钮被点击。


#JQuery基础:
	使用 var div1 = $("#div1");	alert(div1.html());
		$("#div1")：document.getElementById("div1")
		div1.html(): div1.innerHTML

	JQuery对象和Js对象区别与转换
		JQuery对象和js对象方法不通用的．
			*jq -- > js : jq对象[索引]或者jq对象.get(索引)  jq对象都是包装成数组形式的
			*js -- > jq : $(js对象)
	选择器∶筛选具有相似特征的元秦(标签)
		1．基本操作学习:
			1．事件绑定
				$("#b1").click(function(){
					alert( "abc" );
				});
			2．入口函数
				$(function(){});
				window.onload和$(function)区别
				* window.onload 只能定义一次,如果定义多次，后边的会将前边的覆盖掉 
				*$(function)可以定义多次的。
			3．样式控制:css方法
				$("#div1").css("background-color", "red");
				$("#div1").css("backgroundcolor", "pink");
		2．分类
			1．基本选择器
				1．标签选择器(元秦选择器)
					*语法:$("html标签名")获得所有匹配标签名称的元素
				2. id选择器
					*语法:$("#id的属性值")获得与指定id属性值匹配的元秦
				3．类选择器
					*语法:$(".class的属性值")获得与指定的class属性值匹配的元秦
				4．并集选择器︰
					*语法:$("选择器1, 选择器2....")获取多个选择器选中的所有元秦
			2．层级选择器
				1．后代选择器
					*语法:$("A B")选择A元素内部的所有B元素  子孙后代全部
				2．子选择器 
					*语法:$("A > B")选择A元秦内部的所有B子元秦  只是儿子
			3．属性选择器
				1．属性名称选择器
					*语法:$("A[属性名1]")包含指定属性的选择器
				2．属性选择器
					*语法:$("A[属性名='值']")包含指定属性等于指定值的选择器
				3．复合属性选择器
					*语法:$("A[属性名='值'][]...")包含多个属性条件的选择器
				4. $("A[属性名!='值']")表示不包含指定属性或指定属性不等于指定值的选择器
				   $("A[属性名^='值']")表示属性名以指定属性值开头	
				   $("A[属性名$='值']")表示属性名以指定属性值结尾
				   $("A[属性名*='值']")表示属性名包含指定属性值
			4，过滤选择器
				1．首元秦选择器
					*语法: 	:first获得选择的元素中的第一个元秦
					$("div:first").css("backgroundColor", "red");
				2．尾元素选择器
					*语法:	:last获得选择的元素中的最后一个元素
					$("div:last").css("backgroundColor", "red");
				3．非元秦选择器
					*语法:	:not(selector）不包括指定内容的元素  除了not()括号里的 
					$("div:not(.one)").css("backgroundColor", "red");  //改变所有div  除了class=one的
				4．偶数选择器
					*语法:	:even偶数，从0开始计数
					$("div:even").css("backgroundColor", "red"); 
				5．奇数选择器
					*语法:	:odd奇数，从o开始计数
					$("div:odd").css("backgroundColor", "red"); 
				6．等于索引选择器
					*语法:	:eq(index)指定索引元素
					$("div:eq(1)").css("backgroundColor", "red"); 
				7．大于索引选择器
					*语法:	:gt(index)大于指定索引元素
				8．小于索引选择器
					*语法:	:lt(index)小于指定索引元秦
				9．标题选择器
					*语法: 	:header获得标题(h1~h6)元素，固定写法
					$(":header").css("backgroundColor", "red"); 
			5．表单过滤选择器
				1.可用元秦选择器
					*语法: 	:enabled 获得可用元素
					$(input[type='text']:enable).val("xxxxx")  //选择表单中type=text的并且是enable可选的，改变它的值为xxx
				2．不可用元秦选择器
					*语法: 	:disabled 获得不可用元素
					$(input[type='text']:disable).val("xxxxx")  //选择表单中type=text的并且是disable不可选的，改变它的值为xxx
				3．选中选择器
					*语法:	:checked 获得单选/复选框选中的元秦
					$(input[type='checkbox']:checked).length   //选中复选框  得到已经选中的个数
				4．选中选择器
					*语法:	:selected获得下拉框选中的元秦
					$(select > option:selected).length   //选中下拉列表的option元素 并得到已经选中的个数
		DOM操作
			1。内容操作
				1. html():获取/设置元秦的标签体内容	<a><font>内容</font></a> --> <font>内容</font>
				2. text():获取/设置元素的标签体纯文本内容	<a><font>内容</font</a> --> 内容
				3. val():获取/设置元秦的value属性值
					html()和text()的区别：修改内容时，都是修改标签里所有的内容，但html()会将内容改变成html格式，
				而text()会将内容当成字符串直接输出到页面
			2．属性操作
				1．通用属性操作
					1. attr():获取/设置元素的属性
					2. removeAttr():删除属性
					3. prop():获取/设置元素的属性
					4. removeProp():删除属性
					
					*attr和prop区别?
					1. 如果获取/设置的是元素的固有属性，则建议使用prop
					2. 如果获取/设置的是元秦自定义的属性，则建议使用attr
					3. 如果删除的是固有属性或自定义属性，则用removeAttr  可以删除一切
					4. removeProp已经失效
				2．对class属性操作
					1. addclass():添加class属性值
						$("#div").addclass("xxx")  等价于  $("#div").prop("class", "xx")  就是增加了一个class属性
					2. removeclass():删除class属性值
						$("#div").removeclass("xxx") 等价于  $("#div").removeprop("class")
					3. toggleclass():切换class属性
						*toggleclass( "one" ) :
						判断如果元素对象上存在class="one"，则将属性class="one"删除掉。如果元秦对象上不存在class="one"，则添加
					4. css():
						$("#div").css("backgroundColor", "red")  设置背景色为红色
						$("#div").css("backgroundColor")  返回"backgroundColor"对应的值

			3.CRUD操作:
				1. append():父元秦将子元素追加到末尾
					*对象1.append(对象2):将对象2添加到对象1元素内部，并且在末尾
				2. prepend():父元素将子元素追加到开头
					*对象1.prepend (对象2):将对象2添加到对象1元秦内部，并且在开头
				3. appendTo():
					*对象1.appendTo(对象2):将对象1添加到对象2内部，并且在末尾
				4. prependTo() :
					*对象1.prependTo(对象2):将对象1添加到对象2内部，并且在开头
				5. after():添加元秦到元秦后边
					*对象1.after(对象2)︰将对象2添加到对象1后边。对象1和对象2是兄弟关系
				6. before():添加元秦到元素前边
					*对象1.before(对象2)︰将对象2添加到对象1前边。对象1和对象2是兄弟关系
				7. insertAfter()
					*对象1.insertAfter(对象2)︰将对象2添加到对象1后边。对象1和对象2是兄弟关系
				8. insertBefore()
					*对象1.insertBefore(对象2)︰将对象2添加到对象1前边。对象1和对象2是兄弟关系
				9. remove():移除元秦
					*对象.remove():将对象删除掉
				10. empty():清空元素的所有后代元素。
					*对象.empty():将对象的后代元秦全部清空，但是保留当前对象以及其属性节点
	
##JQuery高级
	1．动画
		1. 三种方式显示和隐藏元秦
			1.默认显示和隐藏方式
				1. show(speed, easing, fn) //显示   参数：速度  效果  事件
					1．参数:
						1. speed :动画的速度。三个预定义的值("slow", "normal", "fast")或表示动画时长的毫秒数值(如:1000)
						2. easing:用来指定切换效果，默认是"swing"，可用参数"linear"
							*swing:动画执行时效果是先慢，中间快，最后又慢
							*linear:动画执行时速度是匀速的
						3. fn:在动画完成时执行的函数，每个元秦执行一次。
				2. hide(speed, easing, fn)  //隐藏
				3. toggle(speed, easing, fn)//在显示和隐藏之间切换
			2．滑动显示和隐藏方式
				1. slideDown(speed, easing, fn)
				2. slideup(speed, easing, fn)
				3. slideToggle(speed, easing, fn)
			3．淡入淡出显示和隐藏方式
				1. fadeIn(speed, easing, fn)
				2. fadeout(speed, easing, fn)
				3. fadeToggle(speed, easing, fn)
	2．遍历
		1. js的遍历方式
			*for(初始化值;循环结束条件;步长)
		2. jq的逼历方式
			1. jq对象.each(callback)
				1．语法︰
					jquery对象.each(function(index, element){});
						*index:就是元素在集合中的索引
						*element:就是集合中的每一个元秦对象
						*this:集合中的每一个元素对象
						注意：在each回调函数中，element和this是一样的，但都是JS对象而不是JQ对象，因为JS对象是封装为数组才表现为
						JQ对象的，所以遍历时取出来的是JS对象，要$(this)或$(element)转换为JQ对象才能调用JQ中的各种方法
				2．回调函数返回值︰
					* true:如果当前function返回为false，则结束循环(break)。
					* false:如果当前function返回为true，则结束本次循环，继续下次循环(continue)
			2. $.each(object, callback) 和第一种方式一致
			3. for..of: jquery 3.0 版本之后提供的方式
				for(元素对象 of 容器对象)

	3．事件绑定
		1. jquery标准的绑定方式
			* jq对象.事件方法(回调函数);
			* 注:如果调用事件方法，不传递回调函数，则会触发浏览器默认行为。
				*表单对象.submit();//让表单提交时发生的动作
		2. on绑定事件/off解除绑定
			* jq对象.on("事件名称",回调函数)
			* jq对象.off(“事件名称")
				*如果off方法不传递任何参数，则将组件上的所有事件全部解绑
		3．事件切换:toggle
			*jq对象.toggle(fn1,fn2. ..)
				*当单击jq对象对应的组件后，会执行fn1.第二次点击会执行fn2.. . ..
			*注意:1.9版本.toggle()方法删除,jQuery Migrate(迁移）插件可以恢复此功能。
				<script src="../js/jquery-migrate-1.0.0.js" type="text/javascript"charset= "utf-8"×</script>

	4.插件:增强JQuery的功能
		实现方式∶
			1.$.fn.extend(object) 
				*增强通过Jquery获取的对象的功能$("#id")
			2.$.extend(object)
				*增强Qeury对象自身的功能$/jQuery
		案例：
			1.定义jquery的对象插件: 就是给jquer框架中添加方法，这些方法是所有对象的方法 相当于成员方法
				<script>
					$.fn.extend({
						check:function(){
							this.prop("checked" ,true);
						},
						uncheck:function(){
							this.prop("checked" ,false) ;
						}
					});
					$(function(){
						$("#btn-check").click(function(){
							$("input[type='checkbox']").check();//调用定义的方法
						});
						
						$("#btn-uncheck").click(function() {
							$("input[type= 'checkbox']").uncheck();
						});
					});
				</script>
				
			2.定义jquery的自身插件：也就是全局方法，可以直接调用
				$.extend({
					max: function(a,b){
						return a >= b ? a:b;
					}
				});
				var max =$.max(4,3);//调用全局方法

#AJAX :
	1．概念: ASynchronous Javascript And XML异步的Javascript和XML
		1．异步和同步:客户端和服务器端相互通信的基础上
			*客户端必须等待服务器端的响应。在等待的期间客户端不能做其他操作。
			*客户端不需要等待服务器端的响应。在服务器处理请求的过程中，客户端可以进行其他的操作。
			
			Ajax是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。[1]
			通过在后台与服务器进行少量数据交换，Ajax可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，
			对网页的某部分进行更新。传统的网页(不使用Ajax)如果需要更新内容，必须重载整个网页页面。
			
			提升用户的体验
	2．实现方式:
		1.JS原生实现(了解)
			//发送异步请求
			//1.创建核心对象
			var xmlhttp;
			if(window.XMLHttpRequest){
				//code for IE7+，Firefox,Chrome,Opera,Safari
				xmlhttp=new XMLHttpRequest();
			}
			else {
				// code for IE6，IE5
				xmlhttp=new ActiveXobject("Microsoft.XMLHTTP");
			}
			//2．建立连接
			/*
				参数:
					1．请求方式:GET、POST
						*get方式，请求参数在URL后边拼接。send方法为空参
						*post方式,请求参数在send方法中定义
					2．请求的URL:
					3．同步或异步请求: true(异步)或false(同步)
			*/
			xmlhttp.open("GET", "ajaxServ1et?name=wangyan", true);
			
			//3.发送请求
			xmlhttp.send();
			
			//4.接受并处理来自服务器的响应结果
			//获取方式: xmlhttp.responseText
			//什么时候获取?当服务器响应成功后再获取
			
			//当xmlhttp对象的就绪状态改变时，触发事件onreadystatechange
			xmlhttp.onreadystatechange=function( )
			{
				//判断readyState就绪状态是否为4，判断status响应状态码是否为200
				if(xmlhttp.readyState == 4 && xmlhttp.status==200) {
					//获取服务器的响应结果
					var responseText = xmlhttp.responseText;
					alert(responseText);
				}
			}


		2.JQeury实现方式
			1. $.ajax()
				*语法:$.ajax({键值对});
				$.ajax({
					url: "ajaxservlet”, 				//请求路径
					type:"POST", 						//请求方式
					//data:"username=jack&age=23",
					data:{"username":"jack", "age":23},	//请求参数
					success:function(data) {
						alert(data);
					},									//响应成功后的回调函数  data是服务端返回的数据 是字符串形式
					error:function() {
						alert("出错啦...")
					},									//表示如果请求响应出现错误，会执行的回调函数
					dataType:"text"						//设置接受到的响应数据的格式
				});
			2. $.get():发送get请求
				*语法:$.get(url, [data], [callback], [type])
					参数:
						*url:请求路径
						*data:请求参数
						*callback:回调函数
						*type:响应结果的类型
			3.$.post():发送post请求
#JSON :
	1．概念:Javascript object Notation 		Javascript对象表示法

	2. JSON数据和Java对象的相互转换
		*jSON解析器∶
			*常见的解析器:Jsonlib, Gson, fastjson, jackson
		1.JSON转为Java对象
			1．导入jackson的相关jar包
			2．创建Jackson核心对象objectMapper
			3．调用objectMapper的相关方法进行转换
				1. readvalue(json字符串数据, class)
		2. Java对象转换JSON
			1. 使用步骤︰
				1．导入jackson的相关jar包
				2．创建]ackson核心对象objectMapper
				3．调用objectMapper的相关方法进行转换
					1．转换方法∶
						*writevalue(参数1, obj):
							参数1:
								File :将obj对象转换为JSON字符串，并保存到指定的文件中
								writer:将obj对象转换为JSON字符串，并将json数据填充到字符输出流中
								outputstream : 将obj对象转换为JSON字符串，并将json数据填充到字节输出流中
						*writeValueAsString(obj):将对象转为json字符串
					2．注解∶
						1.@JsonIgnore :排除属性。
						2.@JsonFormat:属性值的格式化
					3．复杂java对象转换
						1. List:数组  转为Json数组
						2. Map:和对象格式一致



			
maven:
	下载压缩文件apache-maven-3.8.2-bin.zip
	目录结构：
		bin：有个mvn.cmd文件   需要将bin路径配置到path环境变量中
		boot：
		conf：配置文件目录  settings.xml文件 
			<!-- localRepository
			   | The path to the local repository maven will use to store artifacts.
			   |
			   | Default: ${user.home}/.m2/repository
			  <localRepository>/path/to/local/repo</localRepository>
			-->	
			Default: ${user.home}/.m2/repository  这是默认的本地仓库位置
			<localRepository>/path/to/local/repo</localRepository> 这是自己设置的本地仓库位置
			远程仓库(私服):本地仓库不需要联网，同一局域网下也可以和远程仓库交换jar包
			中央仓库：本地仓库和远程仓库联网后可以从中央仓库下载jar包
		lib：maven自身运行所依赖的jar包	
	maven项目标准目录结构:	
	src/main/java目录核心代码部分。
	src/main/resources配置文件部分。
	src/test/java目录测试代码部分。
	src/test/resources测试配置文件。
	如果是javaweb项目则会有：src/main/webapp页面资源，js，css，图片等等
	常用命令：
		先cd到项目下：
		mvn clean：删除编译后的文件target文件
		mvn compile：编译src/main/java目录下的文件 生成target文件
		mvn test：编译src/main/java和src/test/java目录下的文件 生成target文件
		mvn package：编译加打包为target目录 pom.xml配置文件中<packaging>war</packaging> 规定打为war包 jar打为jar包
		mvn install：编译加打包为target目录并且存放到本地仓库
	maven概念模型图：D:\Program Files (x86)\maven\apache-maven-3.8.2	
	-DarchetypeCatalog=internal
				
				
				
				
		
		
秦疆：				
ServletContext：共享数据、获取初始化参数、请求转发、读取资源文件
<error-page>
	<error-code>404</error-code>
	<location>/error/404.jsp</location>
</error-page>

<error-page>
	<error-code>500</error-code>
	<location>/error/500.jsp</location>
</error-page>


<%--@include会将两个页面合二为一--%>

<%@include file="common/header.jsp"%>
<h1>网页主体</h1>
<%@include file="common/footer.jsp "%>

<%--jsP标签
	jsp:include:拼接页面，本质还是三个
--%>
<jsp:include page="/common/header.jsp" />
<h1>网页主体</h1>
jsp:include page="/common/footer.jsp" />


变量名							真实类型							作用范围
	*pagecontext				Pagecontext			当前页面共享数据，还可以获取其他八个内置对象
	*request 				HttpservletRequest			一次请求访问的多个资源(转发)
	*session 					Httpsession 				一次会话的多个请求间
	*application 				servletcontext 				所有用户间共享数据
	*response 				HttpservletResponse 				   响应对象
	*page 							object 				当前页面(Servlet)的对象this
	*out 							Jspwriter 				输出对象，数据输出到页面上
	*config 					servletconfig 				servlet的配置对象
	*exception 					Throwable 							异常对象

pageContext.setAttribute( "name1" , "秦疆1号");//保存的数据只在一个页面中有效
request.setAttribute("name2" , "秦疆2号");//保存的数据只在一次请求中有效，请求转发会携带这个数据
session.setAttribute( "name3" , "秦疆3号");//保存的数据只在一次会话中有效，从打开浏览器到关闭浏览器
application.setAttribute ("name4" ,"秦疆4号" );//保存的数据只在服务器中有效，从打开服务器到关闭服务器


//两种转发方式
pageContext.forward("/index.jsp);
request.getRequestDispatcher(" /index.jsp" ).forward(request,response);

PageContext	存东西
Request 	存东西
Response
Session 	存东西
Application 【SerlvetContext】存东西
config【SerlvetConfig】
out
page，不用了解
exceptionI



 静态页面和动态页面的区别
 
一、静态web页面：
1、在静态Web程序中，客户端使用Web浏览器（IE、FireFox等）经过网络(Network)连接到服务器上，使用HTTP协议发起一个请求（Request），告诉服务器我现在需要得到哪个页面，所有的请求交给Web服务器，之后WEB服务器根据用户的需要，从文件系统（存放了所有静态页面的磁盘）取出内容。之后通过Web服务器返回给客户端，客户端接收到内容之后经过浏览器渲染解析，得到显示的效果。
2、为了让静态web页面显示更加好看，使用javascript／VBScript／ajax（AJAX即“Asynchronous Javascript And XML”（异步JavaScript和XML），是指一种创建交互式网页应用的网页开发技术。）但是这些特效都是在客户端上借助于浏览器展现给用户的，所以在服务器上本身并没有任何的变化。
3、静态web无法连接数据库；
4、静态web资源开发技术：HTML；
5、由于现在的web页面中，大量使用JS，导致浏览器打开页面，就会占用大量的内存，服务端的压力是减轻了，但压力转移到了客户端。
 
 
二、动态web页面：
动态WEB中，程序依然使用客户端和服务端，客户端依然使用浏览器（IE、FireFox等），通过网络(Network)连接到服务器上，使用HTTP协议发起请求（Request），现在的所有请求都先经过一个WEB Server来处理。
如果客户端请求的是静态资源(*.htm或者是*.htm)，则将请求直接转交给WEB服务器，之后WEB服务器从文件系统中取出内容，发送回客户端浏览器进行解析执行。
 
如果客户端请求的是动态资源（*.jsp、*.asp/*.aspx、*.php），则先将请求转交给WEB Container(WEB容器)，在WEB Container中连接数据库，从数据库中取出数据等一系列操作后动态拼凑页面的展示内容，拼凑页面的展示内容后，把所有的展示内容交给WEB服务器，之后通过WEB服务器将内容发送回客户端浏览器进行解析执行。
 
再进一步深入分析动态web的访问过程：浏览器访问web时，看似是直接访问的jsp页面，其实是，最先到达的地方是服务器，服务器创建好req和resp对象后再给jsp页面使用。在jsp中完成设置字符集和取得表单参数后再调用servlet，完成业务处理。然后返回到jsp，jsp就会生成相应的html页面。该页面会返回到服务器，再由服务器，通过response对象返回给客户端。
 
为什么需要web服务器？(web server)
1）不管什么web资源，想被远程计算机访问，都必须有一个与之对应的网络通信程序，当用户来访问时，这个网络通信程序读取web资源数据，并把数据发送给来访者。
2）WEB服务器就是这样一个程序，它用于完成底层网络通迅，处理http协议。使用这些服务器，We应用的开发者只需要关注web资源怎么编写，而不需要关心资源如何发送到客户端手中，从而极大的减轻了开发者的开发工作量。
 
常用动态web资源开发技术：JSP/Servlet、ASP、PHP等。
 
 
三、关于两者区别的简单直接的描述
1、静态页面就是设计者把页面上所有东西都设定好、做死了，然后放上去，不管是谁在任何时候看到的页面内容都是一样的，一成不变（除非手动修改页面内容）。静态html页面文件，可以直接用本地的浏览器打开。比如：file:///Users/Phil/Documents/DevOps/HBuilderProjects/testJSP/index.html。
2、动态页面的内容一般都是依靠服务器端的程序来生成的，不同人、不同时候访问页面，显示的内容都可能不同。网页设计者在写好服务器端的页面程序后，不需要手工控制，页面内容会按照页面程序的安排自动更改变换。
3、html是w3c规范的一种网页书写格式，是一种统一协议语言，静态网页。我们上网看的网页都是大部分都是基于html语言的。jsp是一种基于动态语言，jsp可以实现html的所有任务，4、HTML（Hypertext Markup Language）文本标记语言，它是静态页面，和JavaScript一样解释性语言，为什么说是解释性语言呢？因为，只要你有一个浏览器那么它就可以正常显示出来，而不需要指定的编译工具，只需在TXT文档中写上HTML标记就可以正常显示。
JSP（Java Server Page）是Java服务端的页面，所以它是动态的，它是需要经过JDK编译后把内容发给客户端去显示，我们都知道，Java文件编译后会产生一个class文件，最终执行的就是这个class文件，5、JSP的前身是servlet；6、html和jsp的表头不一样，这个是JSP的头“ <%@ page language="java" import="java.util.*" pageEncoding="gbk"%>”在表头中有编码格式和倒入包等。也是很好区分的，在jsp中用<%%>就可以写Java代码了，而html没有<%%>。
7、，不认识jsp或者asp什么什么的，但是有时候界面需要逻辑控制，所以我们就用相应的技术来实现，这样比较方便。而jsp在后台通过服务器解析为相应的html，然后在供浏览器识别显示。例如
<%
if(flag == a){
<label>a<label>
}else {
<label>b<label>
}
%>
服务器在读取到这段代码后，根据相应的业务逻辑，编译成相应的servlet，再由servlet输出到页面（输出的就是html）。


===========================================================maven=================================================================
配置环境变量：
	在我们的系统环境变量中配置如下配置:
		M2_HOME	maven目录下的bin目录
		MAVEN_HOME maven的目录
		在系统的path中配置%MAVEN_HOME%\bin
镜像：
	加速下载
	国内建议使用阿里云的镜像
本地仓库：
	建立一个本地仓库：Default: ${user.home}/.m2/repository
	<localRepository>D:\Program Files (x86)\maven\apache-maven-3.8.2\maven-repo</localRepository>
IDEA中使用maven：
	Bundled是IDEA自带的maven
	编译后WEB-INF下的lib目录会存放maven导入的jar包
	jar包：java应用
	war包：javaWeb应用

maven声明周期：maven构建项目的过程，清理、编译、测试、报告、打包、安装、部署
maven的命令: maven独立使用，通过命令，完成maven的生命周期的执行.maven可以使用命令，完成项目的清理，编译，测试等等↓
maven的插件:maven命令执行时，真正完成功能的是插件，插件就是一些jar文件，一些类


mvn clean
	删除target目录，但是install到仓库中的不会清除
mvn compile
	编译main/java/目录下的java为class文件，同时把class拷贝到target/classes目录下面
	把main/resources目录下的所有文件都拷贝到target/classes目录下
mvn test-compile
	和compile一样，目标是test目录，目标目录为target/test-classes
mvn test
	测试(会生成一个目录surefire-reports，保存测试结果)
mvn package
	打包主程序(会编译、编译测试、测试、并且按照 pom.xml配置把主程序打包生成jar包或者war包)
mvn install
	安装主程序(会把本工程打包，并且按照本工程的坐标保存到本地仓库中)
mvn deploy
	部署主程序(会把本工程打包，按照本工程的坐标保存到本地库中，并且还会保存到私服仓库中。还会自动把项目部署到web容器中)。


	